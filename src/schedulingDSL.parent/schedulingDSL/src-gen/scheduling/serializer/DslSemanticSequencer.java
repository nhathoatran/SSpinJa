/*
 * generated by Xtext 2.10.0
 */
package scheduling.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import scheduling.dsl.And;
import scheduling.dsl.ArrayDec;
import scheduling.dsl.AssertStatement;
import scheduling.dsl.AssignParameters;
import scheduling.dsl.Atomic;
import scheduling.dsl.AttDef;
import scheduling.dsl.Attribute;
import scheduling.dsl.Behavior;
import scheduling.dsl.BlockStatement;
import scheduling.dsl.BoolConstant;
import scheduling.dsl.BoolValue;
import scheduling.dsl.BranchID;
import scheduling.dsl.CTL_AT;
import scheduling.dsl.CallFunction;
import scheduling.dsl.ChanDec;
import scheduling.dsl.ChangeAction;
import scheduling.dsl.ChangeListValue;
import scheduling.dsl.ChangeValueExpression;
import scheduling.dsl.ChangeValueUnOp;
import scheduling.dsl.CheckPoint;
import scheduling.dsl.CollectionInit;
import scheduling.dsl.CompVarDef;
import scheduling.dsl.CompVarDefination;
import scheduling.dsl.CompVarName;
import scheduling.dsl.ComparationDef;
import scheduling.dsl.ComparationName;
import scheduling.dsl.Comparison;
import scheduling.dsl.Component;
import scheduling.dsl.Condition;
import scheduling.dsl.Config;
import scheduling.dsl.ConfigProcess;
import scheduling.dsl.Configs;
import scheduling.dsl.Configuration;
import scheduling.dsl.ConstDec;
import scheduling.dsl.Constraint;
import scheduling.dsl.Constraints;
import scheduling.dsl.Constructor;
import scheduling.dsl.Contains;
import scheduling.dsl.CurentCore;
import scheduling.dsl.DataBlockDef;
import scheduling.dsl.DataDef;
import scheduling.dsl.DataSingleDef;
import scheduling.dsl.DeclareEvent;
import scheduling.dsl.DeclareList;
import scheduling.dsl.DeclareProcess;
import scheduling.dsl.DefBehaviorProc;
import scheduling.dsl.DefCore;
import scheduling.dsl.Define;
import scheduling.dsl.Directory;
import scheduling.dsl.DslPackage;
import scheduling.dsl.ELABEL;
import scheduling.dsl.ELSEs;
import scheduling.dsl.ENAME;
import scheduling.dsl.Element;
import scheduling.dsl.EmptyExpression;
import scheduling.dsl.EnumDec;
import scheduling.dsl.EnumType;
import scheduling.dsl.Equality;
import scheduling.dsl.Event;
import scheduling.dsl.EventDef;
import scheduling.dsl.EventFunction;
import scheduling.dsl.EventOpt;
import scheduling.dsl.EventStm;
import scheduling.dsl.EventTemplate;
import scheduling.dsl.ExecuteProcess;
import scheduling.dsl.ExistExpression;
import scheduling.dsl.ExistP;
import scheduling.dsl.ExistPID;
import scheduling.dsl.FileExtension;
import scheduling.dsl.FileName;
import scheduling.dsl.Flow;
import scheduling.dsl.FullExpression;
import scheduling.dsl.FuncPara;
import scheduling.dsl.Function;
import scheduling.dsl.FunctionName;
import scheduling.dsl.GUARD;
import scheduling.dsl.GenCodeStatement;
import scheduling.dsl.GenComponent;
import scheduling.dsl.GenConfiguration;
import scheduling.dsl.GenDSL;
import scheduling.dsl.GenLnCodeStatement;
import scheduling.dsl.GenPart;
import scheduling.dsl.Generate;
import scheduling.dsl.GenerateOption;
import scheduling.dsl.GetIDExpression;
import scheduling.dsl.GetInstance;
import scheduling.dsl.GetName;
import scheduling.dsl.GetPID;
import scheduling.dsl.GetProcess;
import scheduling.dsl.HandlerDef;
import scheduling.dsl.HasID;
import scheduling.dsl.HasIDINT;
import scheduling.dsl.HasNameExpression;
import scheduling.dsl.IFs;
import scheduling.dsl.ISR;
import scheduling.dsl.IfDef;
import scheduling.dsl.IfStatement;
import scheduling.dsl.Implies;
import scheduling.dsl.InExpression;
import scheduling.dsl.InPExpression;
import scheduling.dsl.InPIDExpression;
import scheduling.dsl.InstanceID;
import scheduling.dsl.IntConstant;
import scheduling.dsl.InterfaceDef;
import scheduling.dsl.InterfaceFunction;
import scheduling.dsl.InterfaceParameterDeclare;
import scheduling.dsl.InterfaceParameterList;
import scheduling.dsl.Invariatnts;
import scheduling.dsl.JavaCode;
import scheduling.dsl.LTE;
import scheduling.dsl.List;
import scheduling.dsl.ListDef;
import scheduling.dsl.ListElement;
import scheduling.dsl.LoopProcess;
import scheduling.dsl.Method;
import scheduling.dsl.Minus;
import scheduling.dsl.Model;
import scheduling.dsl.MoveProcess;
import scheduling.dsl.MulOrDiv;
import scheduling.dsl.ND_Behavior;
import scheduling.dsl.NewElement;
import scheduling.dsl.NewProcessStatement;
import scheduling.dsl.Not;
import scheduling.dsl.NullExpression;
import scheduling.dsl.NumValue;
import scheduling.dsl.OneDec;
import scheduling.dsl.Opt;
import scheduling.dsl.Options;
import scheduling.dsl.Or;
import scheduling.dsl.OrderingDef;
import scheduling.dsl.ParaListItem;
import scheduling.dsl.ParaValue;
import scheduling.dsl.ParameterAssign;
import scheduling.dsl.ParameterList;
import scheduling.dsl.ParameterName;
import scheduling.dsl.PeriodicProcess;
import scheduling.dsl.Permutation;
import scheduling.dsl.Plus;
import scheduling.dsl.PointID;
import scheduling.dsl.PrintLogStatement;
import scheduling.dsl.PrintStatement;
import scheduling.dsl.ProcType;
import scheduling.dsl.ProcessBehavior;
import scheduling.dsl.ProcessBehaviors;
import scheduling.dsl.ProcessConfig;
import scheduling.dsl.ProcessConfiguration;
import scheduling.dsl.ProcessDSL;
import scheduling.dsl.ProcessDataDef;
import scheduling.dsl.ProcessDef;
import scheduling.dsl.ProcessGeneration;
import scheduling.dsl.ProcessID;
import scheduling.dsl.ProcessInit;
import scheduling.dsl.ProcessName;
import scheduling.dsl.ProcessPropertyDef;
import scheduling.dsl.ProcessPropertyName;
import scheduling.dsl.ProcessType;
import scheduling.dsl.Proper;
import scheduling.dsl.PropertyAssignment;
import scheduling.dsl.QualifiedNames;
import scheduling.dsl.RTCTL;
import scheduling.dsl.Range;
import scheduling.dsl.RefList;
import scheduling.dsl.RefListItem;
import scheduling.dsl.RemoveProcess;
import scheduling.dsl.ReorderProcess;
import scheduling.dsl.ReturnStatement;
import scheduling.dsl.Rule;
import scheduling.dsl.Rules;
import scheduling.dsl.SKIP;
import scheduling.dsl.Scenarios;
import scheduling.dsl.SchedulerCollectionDef;
import scheduling.dsl.SchedulerDSL;
import scheduling.dsl.SchedulerDataDef;
import scheduling.dsl.SchedulerDef;
import scheduling.dsl.SchedulerInit;
import scheduling.dsl.SchedulerPropertyDef;
import scheduling.dsl.SchedulerPropertyName;
import scheduling.dsl.SchedulerSet;
import scheduling.dsl.SequenceAction;
import scheduling.dsl.SetExecTime;
import scheduling.dsl.SetProcess;
import scheduling.dsl.SetProcessInstance;
import scheduling.dsl.SetReturnCol;
import scheduling.dsl.SetReturnSet;
import scheduling.dsl.SetTemplate;
import scheduling.dsl.Specification;
import scheduling.dsl.SporadicProcess;
import scheduling.dsl.StateID;
import scheduling.dsl.Step;
import scheduling.dsl.StepGeneration;
import scheduling.dsl.Stm;
import scheduling.dsl.SysVar;
import scheduling.dsl.Template;
import scheduling.dsl.TestDSL;
import scheduling.dsl.TestPart;
import scheduling.dsl.TotalStep;
import scheduling.dsl.VDec;
import scheduling.dsl.Value;
import scheduling.dsl.VarBlockDef;
import scheduling.dsl.VarDec;
import scheduling.dsl.VarDecl;
import scheduling.dsl.VarDef;
import scheduling.dsl.VarDefinition;
import scheduling.dsl.VarInit;
import scheduling.dsl.VarName;
import scheduling.dsl.VarSingleDef;
import scheduling.dsl.Verify;
import scheduling.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.ACTION:
				sequence_Atomic(context, (scheduling.dsl.Action) semanticObject); 
				return; 
			case DslPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case DslPackage.ARRAY_DEC:
				sequence_ArrayDec(context, (ArrayDec) semanticObject); 
				return; 
			case DslPackage.ASSERT_STATEMENT:
				sequence_AssertStatement(context, (AssertStatement) semanticObject); 
				return; 
			case DslPackage.ASSIGN_PARAMETERS:
				sequence_AssignParameters(context, (AssignParameters) semanticObject); 
				return; 
			case DslPackage.ATOMIC:
				sequence_Atomic(context, (Atomic) semanticObject); 
				return; 
			case DslPackage.ATT_DEF:
				sequence_AttDef(context, (AttDef) semanticObject); 
				return; 
			case DslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case DslPackage.BEHAVIOR:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getImpliesRule()
						|| action == grammarAccess.getImpliesAccess().getImpliesLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (Behavior) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBehaviorRule()) {
					sequence_Behavior(context, (Behavior) semanticObject); 
					return; 
				}
				else break;
			case DslPackage.BLOCK_STATEMENT:
				sequence_BlockStatement(context, (BlockStatement) semanticObject); 
				return; 
			case DslPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case DslPackage.BOOL_VALUE:
				sequence_BoolValue(context, (BoolValue) semanticObject); 
				return; 
			case DslPackage.BRANCH_ID:
				sequence_Atomic(context, (BranchID) semanticObject); 
				return; 
			case DslPackage.CTL_AT:
				sequence_CTL_AT(context, (CTL_AT) semanticObject); 
				return; 
			case DslPackage.CALL_FUNCTION:
				sequence_CallFunction(context, (CallFunction) semanticObject); 
				return; 
			case DslPackage.CHAN_DEC:
				sequence_ChanDec(context, (ChanDec) semanticObject); 
				return; 
			case DslPackage.CHANGE_ACTION:
				sequence_ChangeAction(context, (ChangeAction) semanticObject); 
				return; 
			case DslPackage.CHANGE_LIST_VALUE:
				sequence_ChangeListValue(context, (ChangeListValue) semanticObject); 
				return; 
			case DslPackage.CHANGE_VALUE_EXPRESSION:
				sequence_ChangeValueExpression(context, (ChangeValueExpression) semanticObject); 
				return; 
			case DslPackage.CHANGE_VALUE_UN_OP:
				sequence_ChangeValueUnOp(context, (ChangeValueUnOp) semanticObject); 
				return; 
			case DslPackage.CHECK_POINT:
				sequence_CheckPoint(context, (CheckPoint) semanticObject); 
				return; 
			case DslPackage.COLLECTION_INIT:
				sequence_CollectionInit(context, (CollectionInit) semanticObject); 
				return; 
			case DslPackage.COMP_VAR_DEF:
				sequence_CompVarDef(context, (CompVarDef) semanticObject); 
				return; 
			case DslPackage.COMP_VAR_DEFINATION:
				sequence_CompVarDefination(context, (CompVarDefination) semanticObject); 
				return; 
			case DslPackage.COMP_VAR_NAME:
				sequence_CompVarName(context, (CompVarName) semanticObject); 
				return; 
			case DslPackage.COMPARATION_DEF:
				sequence_ComparationDef(context, (ComparationDef) semanticObject); 
				return; 
			case DslPackage.COMPARATION_NAME:
				sequence_ComparationName(context, (ComparationName) semanticObject); 
				return; 
			case DslPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case DslPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case DslPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case DslPackage.CONFIG:
				sequence_Config(context, (Config) semanticObject); 
				return; 
			case DslPackage.CONFIG_PROCESS:
				sequence_ConfigProcess(context, (ConfigProcess) semanticObject); 
				return; 
			case DslPackage.CONFIGS:
				sequence_Configs(context, (Configs) semanticObject); 
				return; 
			case DslPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case DslPackage.CONST_DEC:
				sequence_ConstDec(context, (ConstDec) semanticObject); 
				return; 
			case DslPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case DslPackage.CONSTRAINTS:
				sequence_Constraints(context, (Constraints) semanticObject); 
				return; 
			case DslPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case DslPackage.CONTAINS:
				sequence_Atomic(context, (Contains) semanticObject); 
				return; 
			case DslPackage.CURENT_CORE:
				sequence_Atomic(context, (CurentCore) semanticObject); 
				return; 
			case DslPackage.DATA_BLOCK_DEF:
				sequence_DataBlockDef(context, (DataBlockDef) semanticObject); 
				return; 
			case DslPackage.DATA_DEF:
				sequence_DataDef(context, (DataDef) semanticObject); 
				return; 
			case DslPackage.DATA_SINGLE_DEF:
				sequence_DataSingleDef(context, (DataSingleDef) semanticObject); 
				return; 
			case DslPackage.DECLARE_EVENT:
				sequence_DeclareEvent(context, (DeclareEvent) semanticObject); 
				return; 
			case DslPackage.DECLARE_LIST:
				sequence_DeclareList(context, (DeclareList) semanticObject); 
				return; 
			case DslPackage.DECLARE_PROCESS:
				sequence_DeclareProcess(context, (DeclareProcess) semanticObject); 
				return; 
			case DslPackage.DEF_BEHAVIOR_PROC:
				sequence_DefBehaviorProc(context, (DefBehaviorProc) semanticObject); 
				return; 
			case DslPackage.DEF_CORE:
				sequence_DefCore(context, (DefCore) semanticObject); 
				return; 
			case DslPackage.DEFINE:
				sequence_Define(context, (Define) semanticObject); 
				return; 
			case DslPackage.DIRECTORY:
				sequence_Directory(context, (Directory) semanticObject); 
				return; 
			case DslPackage.ELABEL:
				sequence_ELABEL(context, (ELABEL) semanticObject); 
				return; 
			case DslPackage.ELS_ES:
				sequence_ELSEs(context, (ELSEs) semanticObject); 
				return; 
			case DslPackage.ENAME:
				sequence_ENAME(context, (ENAME) semanticObject); 
				return; 
			case DslPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case DslPackage.EMPTY_EXPRESSION:
				sequence_EmptyExpression(context, (EmptyExpression) semanticObject); 
				return; 
			case DslPackage.ENUM_DEC:
				sequence_EnumDec(context, (EnumDec) semanticObject); 
				return; 
			case DslPackage.ENUM_TYPE:
				sequence_EnumType(context, (EnumType) semanticObject); 
				return; 
			case DslPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case DslPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case DslPackage.EVENT_DEF:
				sequence_EventDef(context, (EventDef) semanticObject); 
				return; 
			case DslPackage.EVENT_FUNCTION:
				sequence_EventFunction(context, (EventFunction) semanticObject); 
				return; 
			case DslPackage.EVENT_OPT:
				sequence_EventOpt(context, (EventOpt) semanticObject); 
				return; 
			case DslPackage.EVENT_STM:
				sequence_EventStm(context, (EventStm) semanticObject); 
				return; 
			case DslPackage.EVENT_TEMPLATE:
				sequence_EventTemplate(context, (EventTemplate) semanticObject); 
				return; 
			case DslPackage.EXECUTE_PROCESS:
				sequence_ExecuteProcess(context, (ExecuteProcess) semanticObject); 
				return; 
			case DslPackage.EXIST_EXPRESSION:
				sequence_ExistExpression(context, (ExistExpression) semanticObject); 
				return; 
			case DslPackage.EXIST_P:
				sequence_ExistP(context, (ExistP) semanticObject); 
				return; 
			case DslPackage.EXIST_PID:
				sequence_ExistPID(context, (ExistPID) semanticObject); 
				return; 
			case DslPackage.FILE_EXTENSION:
				sequence_FileExtension(context, (FileExtension) semanticObject); 
				return; 
			case DslPackage.FILE_NAME:
				sequence_FileName(context, (FileName) semanticObject); 
				return; 
			case DslPackage.FLOW:
				sequence_Flow(context, (Flow) semanticObject); 
				return; 
			case DslPackage.FULL_EXPRESSION:
				sequence_FullExpression(context, (FullExpression) semanticObject); 
				return; 
			case DslPackage.FUNC_PARA:
				sequence_FuncPara(context, (FuncPara) semanticObject); 
				return; 
			case DslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case DslPackage.FUNCTION_NAME:
				sequence_FunctionName(context, (FunctionName) semanticObject); 
				return; 
			case DslPackage.GUARD:
				sequence_GUARD(context, (GUARD) semanticObject); 
				return; 
			case DslPackage.GEN_CODE_STATEMENT:
				sequence_GenCodeStatement(context, (GenCodeStatement) semanticObject); 
				return; 
			case DslPackage.GEN_COMPONENT:
				sequence_GenComponent(context, (GenComponent) semanticObject); 
				return; 
			case DslPackage.GEN_CONFIGURATION:
				sequence_GenConfiguration(context, (GenConfiguration) semanticObject); 
				return; 
			case DslPackage.GEN_DSL:
				sequence_GenDSL(context, (GenDSL) semanticObject); 
				return; 
			case DslPackage.GEN_LN_CODE_STATEMENT:
				sequence_GenLnCodeStatement(context, (GenLnCodeStatement) semanticObject); 
				return; 
			case DslPackage.GEN_PART:
				sequence_GenPart(context, (GenPart) semanticObject); 
				return; 
			case DslPackage.GENERATE:
				sequence_Generate(context, (Generate) semanticObject); 
				return; 
			case DslPackage.GENERATE_OPTION:
				sequence_GenerateOption(context, (GenerateOption) semanticObject); 
				return; 
			case DslPackage.GET_ID_EXPRESSION:
				sequence_GetIDExpression(context, (GetIDExpression) semanticObject); 
				return; 
			case DslPackage.GET_INSTANCE:
				sequence_Atomic(context, (GetInstance) semanticObject); 
				return; 
			case DslPackage.GET_NAME:
				sequence_GetName(context, (GetName) semanticObject); 
				return; 
			case DslPackage.GET_PID:
				sequence_Atomic(context, (GetPID) semanticObject); 
				return; 
			case DslPackage.GET_PROCESS:
				sequence_GetProcess(context, (GetProcess) semanticObject); 
				return; 
			case DslPackage.HANDLER_DEF:
				sequence_HandlerDef(context, (HandlerDef) semanticObject); 
				return; 
			case DslPackage.HAS_ID:
				sequence_HasID(context, (HasID) semanticObject); 
				return; 
			case DslPackage.HAS_IDINT:
				sequence_HasIDINT(context, (HasIDINT) semanticObject); 
				return; 
			case DslPackage.HAS_NAME_EXPRESSION:
				sequence_HasNameExpression(context, (HasNameExpression) semanticObject); 
				return; 
			case DslPackage.IFS:
				sequence_IFs(context, (IFs) semanticObject); 
				return; 
			case DslPackage.ISR:
				sequence_ISR(context, (ISR) semanticObject); 
				return; 
			case DslPackage.IF_DEF:
				sequence_IfDef(context, (IfDef) semanticObject); 
				return; 
			case DslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case DslPackage.IMPLIES:
				sequence_Implies(context, (Implies) semanticObject); 
				return; 
			case DslPackage.IN_EXPRESSION:
				sequence_InExpression(context, (InExpression) semanticObject); 
				return; 
			case DslPackage.IN_PEXPRESSION:
				sequence_InPExpression(context, (InPExpression) semanticObject); 
				return; 
			case DslPackage.IN_PID_EXPRESSION:
				sequence_InPIDExpression(context, (InPIDExpression) semanticObject); 
				return; 
			case DslPackage.INSTANCE_ID:
				sequence_Atomic(context, (InstanceID) semanticObject); 
				return; 
			case DslPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case DslPackage.INTERFACE_DEF:
				sequence_InterfaceDef(context, (InterfaceDef) semanticObject); 
				return; 
			case DslPackage.INTERFACE_FUNCTION:
				sequence_InterfaceFunction(context, (InterfaceFunction) semanticObject); 
				return; 
			case DslPackage.INTERFACE_PARAMETER_DECLARE:
				sequence_InterfaceParameterDeclare(context, (InterfaceParameterDeclare) semanticObject); 
				return; 
			case DslPackage.INTERFACE_PARAMETER_LIST:
				sequence_InterfaceParameterList(context, (InterfaceParameterList) semanticObject); 
				return; 
			case DslPackage.INVARIATNTS:
				sequence_Invariants(context, (Invariatnts) semanticObject); 
				return; 
			case DslPackage.JAVA_CODE:
				sequence_JavaCode(context, (JavaCode) semanticObject); 
				return; 
			case DslPackage.LTE:
				sequence_LTE(context, (LTE) semanticObject); 
				return; 
			case DslPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case DslPackage.LIST_DEF:
				sequence_ListDef(context, (ListDef) semanticObject); 
				return; 
			case DslPackage.LIST_ELEMENT:
				sequence_ListElement(context, (ListElement) semanticObject); 
				return; 
			case DslPackage.LOOP_PROCESS:
				sequence_LoopProcess(context, (LoopProcess) semanticObject); 
				return; 
			case DslPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case DslPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case DslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DslPackage.MOVE_PROCESS:
				sequence_MoveProcess(context, (MoveProcess) semanticObject); 
				return; 
			case DslPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case DslPackage.ND_BEHAVIOR:
				sequence_ND_Behavior(context, (ND_Behavior) semanticObject); 
				return; 
			case DslPackage.NEW_ELEMENT:
				sequence_NewElement(context, (NewElement) semanticObject); 
				return; 
			case DslPackage.NEW_PROCESS_STATEMENT:
				sequence_NewProcessStatement(context, (NewProcessStatement) semanticObject); 
				return; 
			case DslPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case DslPackage.NULL_EXPRESSION:
				sequence_NullExpression(context, (NullExpression) semanticObject); 
				return; 
			case DslPackage.NUM_VALUE:
				sequence_NumValue(context, (NumValue) semanticObject); 
				return; 
			case DslPackage.ONE_DEC:
				sequence_OneDec(context, (OneDec) semanticObject); 
				return; 
			case DslPackage.OPT:
				sequence_Opt(context, (Opt) semanticObject); 
				return; 
			case DslPackage.OPTIONS:
				sequence_Options(context, (Options) semanticObject); 
				return; 
			case DslPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case DslPackage.ORDERING_DEF:
				sequence_OrderingDef(context, (OrderingDef) semanticObject); 
				return; 
			case DslPackage.PARA_LIST_ITEM:
				sequence_ParaListItem(context, (ParaListItem) semanticObject); 
				return; 
			case DslPackage.PARA_VALUE:
				sequence_ParaValue(context, (ParaValue) semanticObject); 
				return; 
			case DslPackage.PARAMETER_ASSIGN:
				sequence_ParameterAssign(context, (ParameterAssign) semanticObject); 
				return; 
			case DslPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case DslPackage.PARAMETER_NAME:
				sequence_ParameterName(context, (ParameterName) semanticObject); 
				return; 
			case DslPackage.PERIODIC_PROCESS:
				sequence_PeriodicProcess(context, (PeriodicProcess) semanticObject); 
				return; 
			case DslPackage.PERMUTATION:
				sequence_Permutation(context, (Permutation) semanticObject); 
				return; 
			case DslPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case DslPackage.POINT_ID:
				sequence_PointID(context, (PointID) semanticObject); 
				return; 
			case DslPackage.PRINT_LOG_STATEMENT:
				sequence_PrintLogStatement(context, (PrintLogStatement) semanticObject); 
				return; 
			case DslPackage.PRINT_STATEMENT:
				sequence_PrintStatement(context, (PrintStatement) semanticObject); 
				return; 
			case DslPackage.PROC_TYPE:
				sequence_ProcType(context, (ProcType) semanticObject); 
				return; 
			case DslPackage.PROCESS:
				sequence_Process(context, (scheduling.dsl.Process) semanticObject); 
				return; 
			case DslPackage.PROCESS_BEHAVIOR:
				sequence_ProcessBehavior(context, (ProcessBehavior) semanticObject); 
				return; 
			case DslPackage.PROCESS_BEHAVIORS:
				sequence_ProcessBehaviors(context, (ProcessBehaviors) semanticObject); 
				return; 
			case DslPackage.PROCESS_CONFIG:
				sequence_ProcessConfig(context, (ProcessConfig) semanticObject); 
				return; 
			case DslPackage.PROCESS_CONFIGURATION:
				sequence_ProcessConfiguration(context, (ProcessConfiguration) semanticObject); 
				return; 
			case DslPackage.PROCESS_DSL:
				sequence_ProcessDSL(context, (ProcessDSL) semanticObject); 
				return; 
			case DslPackage.PROCESS_DATA_DEF:
				sequence_ProcessDataDef(context, (ProcessDataDef) semanticObject); 
				return; 
			case DslPackage.PROCESS_DEF:
				sequence_ProcessDef(context, (ProcessDef) semanticObject); 
				return; 
			case DslPackage.PROCESS_GENERATION:
				sequence_ProcessGeneration(context, (ProcessGeneration) semanticObject); 
				return; 
			case DslPackage.PROCESS_ID:
				sequence_Atomic(context, (ProcessID) semanticObject); 
				return; 
			case DslPackage.PROCESS_INIT:
				sequence_ProcessInit(context, (ProcessInit) semanticObject); 
				return; 
			case DslPackage.PROCESS_NAME:
				sequence_Atomic(context, (ProcessName) semanticObject); 
				return; 
			case DslPackage.PROCESS_PROPERTY_DEF:
				sequence_ProcessPropertyDef(context, (ProcessPropertyDef) semanticObject); 
				return; 
			case DslPackage.PROCESS_PROPERTY_NAME:
				sequence_ProcessPropertyName(context, (ProcessPropertyName) semanticObject); 
				return; 
			case DslPackage.PROCESS_TYPE:
				sequence_ProcessType(context, (ProcessType) semanticObject); 
				return; 
			case DslPackage.PROPER:
				sequence_Proper(context, (Proper) semanticObject); 
				return; 
			case DslPackage.PROPERTY_ASSIGNMENT:
				sequence_PropertyAssignment(context, (PropertyAssignment) semanticObject); 
				return; 
			case DslPackage.QUALIFIED_NAMES:
				sequence_QualifiedNames(context, (QualifiedNames) semanticObject); 
				return; 
			case DslPackage.RTCTL:
				sequence_RTCTL(context, (RTCTL) semanticObject); 
				return; 
			case DslPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case DslPackage.REF_LIST:
				sequence_RefList(context, (RefList) semanticObject); 
				return; 
			case DslPackage.REF_LIST_ITEM:
				sequence_RefListItem(context, (RefListItem) semanticObject); 
				return; 
			case DslPackage.REMOVE_PROCESS:
				sequence_RemoveProcess(context, (RemoveProcess) semanticObject); 
				return; 
			case DslPackage.REORDER_PROCESS:
				sequence_ReorderProcess(context, (ReorderProcess) semanticObject); 
				return; 
			case DslPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case DslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case DslPackage.RULES:
				sequence_Rules(context, (Rules) semanticObject); 
				return; 
			case DslPackage.SKIP:
				sequence_SKIP(context, (SKIP) semanticObject); 
				return; 
			case DslPackage.SCENARIOS:
				sequence_Scenarios(context, (Scenarios) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_COLLECTION_DEF:
				sequence_SchedulerCollectionDef(context, (SchedulerCollectionDef) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_DSL:
				sequence_SchedulerDSL(context, (SchedulerDSL) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_DATA_DEF:
				sequence_SchedulerDataDef(context, (SchedulerDataDef) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_DEF:
				sequence_SchedulerDef(context, (SchedulerDef) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_INIT:
				sequence_SchedulerInit(context, (SchedulerInit) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_PROPERTY_DEF:
				sequence_SchedulerPropertyDef(context, (SchedulerPropertyDef) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_PROPERTY_NAME:
				sequence_SchedulerPropertyName(context, (SchedulerPropertyName) semanticObject); 
				return; 
			case DslPackage.SCHEDULER_SET:
				sequence_SchedulerSet(context, (SchedulerSet) semanticObject); 
				return; 
			case DslPackage.SEQUENCE_ACTION:
				sequence_SequenceAction(context, (SequenceAction) semanticObject); 
				return; 
			case DslPackage.SET:
				sequence_Set(context, (scheduling.dsl.Set) semanticObject); 
				return; 
			case DslPackage.SET_EXEC_TIME:
				sequence_SetExecTime(context, (SetExecTime) semanticObject); 
				return; 
			case DslPackage.SET_PROCESS:
				sequence_SetProcess(context, (SetProcess) semanticObject); 
				return; 
			case DslPackage.SET_PROCESS_INSTANCE:
				sequence_SetProcessInstance(context, (SetProcessInstance) semanticObject); 
				return; 
			case DslPackage.SET_RETURN_COL:
				sequence_SetReturnCol(context, (SetReturnCol) semanticObject); 
				return; 
			case DslPackage.SET_RETURN_SET:
				sequence_SetReturnSet(context, (SetReturnSet) semanticObject); 
				return; 
			case DslPackage.SET_TEMPLATE:
				sequence_SetTemplate(context, (SetTemplate) semanticObject); 
				return; 
			case DslPackage.SPECIFICATION:
				sequence_Specification(context, (Specification) semanticObject); 
				return; 
			case DslPackage.SPORADIC_PROCESS:
				sequence_SporadicProcess(context, (SporadicProcess) semanticObject); 
				return; 
			case DslPackage.STATE_ID:
				sequence_Atomic(context, (StateID) semanticObject); 
				return; 
			case DslPackage.STEP:
				sequence_Atomic(context, (Step) semanticObject); 
				return; 
			case DslPackage.STEP_GENERATION:
				sequence_StepGeneration(context, (StepGeneration) semanticObject); 
				return; 
			case DslPackage.STM:
				sequence_Stm(context, (Stm) semanticObject); 
				return; 
			case DslPackage.SYS_VAR:
				sequence_SysVar(context, (SysVar) semanticObject); 
				return; 
			case DslPackage.TEMPLATE:
				sequence_Template(context, (Template) semanticObject); 
				return; 
			case DslPackage.TEST_DSL:
				sequence_TestDSL(context, (TestDSL) semanticObject); 
				return; 
			case DslPackage.TEST_PART:
				sequence_TestPart(context, (TestPart) semanticObject); 
				return; 
			case DslPackage.TOTAL_STEP:
				sequence_Atomic(context, (TotalStep) semanticObject); 
				return; 
			case DslPackage.VDEC:
				sequence_VDec(context, (VDec) semanticObject); 
				return; 
			case DslPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case DslPackage.VAR_BLOCK_DEF:
				sequence_VarBlockDef(context, (VarBlockDef) semanticObject); 
				return; 
			case DslPackage.VAR_DEC:
				sequence_VarDec(context, (VarDec) semanticObject); 
				return; 
			case DslPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			case DslPackage.VAR_DEF:
				sequence_VarDef(context, (VarDef) semanticObject); 
				return; 
			case DslPackage.VAR_DEFINITION:
				sequence_VarDefinition(context, (VarDefinition) semanticObject); 
				return; 
			case DslPackage.VAR_INIT:
				sequence_VarInit(context, (VarInit) semanticObject); 
				return; 
			case DslPackage.VAR_NAME:
				sequence_VarName(context, (VarName) semanticObject); 
				return; 
			case DslPackage.VAR_SINGLE_DEF:
				sequence_VarSingleDef(context, (VarSingleDef) semanticObject); 
				return; 
			case DslPackage.VERIFY:
				sequence_Verify(context, (Verify) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.MulOrDiv_1_0 returns And
	 *     Implies returns And
	 *     Implies.Implies_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getAnd_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getAnd_Left()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getAnd_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getAnd_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayDec returns ArrayDec
	 *
	 * Constraint:
	 *     (type=TypeName aName=ID num=NumValue)
	 */
	protected void sequence_ArrayDec(ISerializationContext context, ArrayDec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getArrayDec_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getArrayDec_Type()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getArrayDec_AName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getArrayDec_AName()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getArrayDec_Num()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getArrayDec_Num()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayDecAccess().getTypeTypeNameEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getArrayDecAccess().getANameIDTerminalRuleCall_1_0(), semanticObject.getAName());
		feeder.accept(grammarAccess.getArrayDecAccess().getNumNumValueParserRuleCall_3_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssertStatement
	 *     AssertStatement returns AssertStatement
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_AssertStatement(ISerializationContext context, AssertStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getAssertStatement_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getAssertStatement_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertStatementAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssignParameters returns AssignParameters
	 *
	 * Constraint:
	 *     (paraname=ID list=ListDef)
	 */
	protected void sequence_AssignParameters(ISerializationContext context, AssignParameters semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getAssignParameters_Paraname()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getAssignParameters_Paraname()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getAssignParameters_List()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getAssignParameters_List()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignParametersAccess().getParanameIDTerminalRuleCall_0_0(), semanticObject.getParaname());
		feeder.accept(grammarAccess.getAssignParametersAccess().getListListDefParserRuleCall_4_0(), semanticObject.getList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Action
	 *     Or returns Action
	 *     Or.Or_1_0 returns Action
	 *     And returns Action
	 *     And.And_1_0 returns Action
	 *     Equality returns Action
	 *     Equality.Equality_1_0 returns Action
	 *     Comparison returns Action
	 *     Comparison.Comparison_1_0 returns Action
	 *     PlusOrMinus returns Action
	 *     PlusOrMinus.Plus_1_0_0_0 returns Action
	 *     PlusOrMinus.Minus_1_0_1_0 returns Action
	 *     MulOrDiv returns Action
	 *     MulOrDiv.MulOrDiv_1_0 returns Action
	 *     Implies returns Action
	 *     Implies.Implies_1_0 returns Action
	 *     Primary returns Action
	 *     Atomic returns Action
	 *
	 * Constraint:
	 *     action='getAction()'
	 */
	protected void sequence_Atomic(ISerializationContext context, scheduling.dsl.Action semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getAction_Action()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getAction_Action()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getActionGetActionKeyword_5_1_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Atomic
	 *     Or returns Atomic
	 *     Or.Or_1_0 returns Atomic
	 *     And returns Atomic
	 *     And.And_1_0 returns Atomic
	 *     Equality returns Atomic
	 *     Equality.Equality_1_0 returns Atomic
	 *     Comparison returns Atomic
	 *     Comparison.Comparison_1_0 returns Atomic
	 *     PlusOrMinus returns Atomic
	 *     PlusOrMinus.Plus_1_0_0_0 returns Atomic
	 *     PlusOrMinus.Minus_1_0_1_0 returns Atomic
	 *     MulOrDiv returns Atomic
	 *     MulOrDiv.MulOrDiv_1_0 returns Atomic
	 *     Implies returns Atomic
	 *     Implies.Implies_1_0 returns Atomic
	 *     Primary returns Atomic
	 *     Atomic returns Atomic
	 *
	 * Constraint:
	 *     (var=QualifiedNames | lele=ListElement | charseq=CHAR_SEQUENCE | string=STRING | sysvar=SysVar)
	 */
	protected void sequence_Atomic(ISerializationContext context, Atomic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Behavior
	 *     Or returns Behavior
	 *     Or.Or_1_0 returns Behavior
	 *     And returns Behavior
	 *     And.And_1_0 returns Behavior
	 *     Equality returns Behavior
	 *     Equality.Equality_1_0 returns Behavior
	 *     Comparison returns Behavior
	 *     Comparison.Comparison_1_0 returns Behavior
	 *     PlusOrMinus returns Behavior
	 *     PlusOrMinus.Plus_1_0_0_0 returns Behavior
	 *     PlusOrMinus.Minus_1_0_1_0 returns Behavior
	 *     MulOrDiv returns Behavior
	 *     MulOrDiv.MulOrDiv_1_0 returns Behavior
	 *     Implies returns Behavior
	 *     Implies.Implies_1_0 returns Behavior
	 *     Primary returns Behavior
	 *     Atomic returns Behavior
	 *
	 * Constraint:
	 *     behavior='<actions>'
	 */
	protected void sequence_Atomic(ISerializationContext context, Behavior semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getBehavior_Behavior()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getBehavior_Behavior()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getBehaviorActionsKeyword_13_1_0(), semanticObject.getBehavior());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns BoolConstant
	 *     Implies returns BoolConstant
	 *     Implies.Implies_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BranchID
	 *     Or returns BranchID
	 *     Or.Or_1_0 returns BranchID
	 *     And returns BranchID
	 *     And.And_1_0 returns BranchID
	 *     Equality returns BranchID
	 *     Equality.Equality_1_0 returns BranchID
	 *     Comparison returns BranchID
	 *     Comparison.Comparison_1_0 returns BranchID
	 *     PlusOrMinus returns BranchID
	 *     PlusOrMinus.Plus_1_0_0_0 returns BranchID
	 *     PlusOrMinus.Minus_1_0_1_0 returns BranchID
	 *     MulOrDiv returns BranchID
	 *     MulOrDiv.MulOrDiv_1_0 returns BranchID
	 *     Implies returns BranchID
	 *     Implies.Implies_1_0 returns BranchID
	 *     Primary returns BranchID
	 *     Atomic returns BranchID
	 *
	 * Constraint:
	 *     branchID='<BranchID>'
	 */
	protected void sequence_Atomic(ISerializationContext context, BranchID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getBranchID_BranchID()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getBranchID_BranchID()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getBranchIDBranchIDKeyword_4_1_0(), semanticObject.getBranchID());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Contains
	 *     Or returns Contains
	 *     Or.Or_1_0 returns Contains
	 *     And returns Contains
	 *     And.And_1_0 returns Contains
	 *     Equality returns Contains
	 *     Equality.Equality_1_0 returns Contains
	 *     Comparison returns Contains
	 *     Comparison.Comparison_1_0 returns Contains
	 *     PlusOrMinus returns Contains
	 *     PlusOrMinus.Plus_1_0_0_0 returns Contains
	 *     PlusOrMinus.Minus_1_0_1_0 returns Contains
	 *     MulOrDiv returns Contains
	 *     MulOrDiv.MulOrDiv_1_0 returns Contains
	 *     Implies returns Contains
	 *     Implies.Implies_1_0 returns Contains
	 *     Primary returns Contains
	 *     Atomic returns Contains
	 *
	 * Constraint:
	 *     contains='<contains>'
	 */
	protected void sequence_Atomic(ISerializationContext context, Contains semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getContains_Contains()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getContains_Contains()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getContainsContainsKeyword_14_1_0(), semanticObject.getContains());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CurentCore
	 *     Or returns CurentCore
	 *     Or.Or_1_0 returns CurentCore
	 *     And returns CurentCore
	 *     And.And_1_0 returns CurentCore
	 *     Equality returns CurentCore
	 *     Equality.Equality_1_0 returns CurentCore
	 *     Comparison returns CurentCore
	 *     Comparison.Comparison_1_0 returns CurentCore
	 *     PlusOrMinus returns CurentCore
	 *     PlusOrMinus.Plus_1_0_0_0 returns CurentCore
	 *     PlusOrMinus.Minus_1_0_1_0 returns CurentCore
	 *     MulOrDiv returns CurentCore
	 *     MulOrDiv.MulOrDiv_1_0 returns CurentCore
	 *     Implies returns CurentCore
	 *     Implies.Implies_1_0 returns CurentCore
	 *     Primary returns CurentCore
	 *     Atomic returns CurentCore
	 *
	 * Constraint:
	 *     value='current_core'
	 */
	protected void sequence_Atomic(ISerializationContext context, CurentCore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getCurentCore_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getCurentCore_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueCurrent_coreKeyword_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GetInstance
	 *     Or returns GetInstance
	 *     Or.Or_1_0 returns GetInstance
	 *     And returns GetInstance
	 *     And.And_1_0 returns GetInstance
	 *     Equality returns GetInstance
	 *     Equality.Equality_1_0 returns GetInstance
	 *     Comparison returns GetInstance
	 *     Comparison.Comparison_1_0 returns GetInstance
	 *     PlusOrMinus returns GetInstance
	 *     PlusOrMinus.Plus_1_0_0_0 returns GetInstance
	 *     PlusOrMinus.Minus_1_0_1_0 returns GetInstance
	 *     MulOrDiv returns GetInstance
	 *     MulOrDiv.MulOrDiv_1_0 returns GetInstance
	 *     Implies returns GetInstance
	 *     Implies.Implies_1_0 returns GetInstance
	 *     Primary returns GetInstance
	 *     Atomic returns GetInstance
	 *
	 * Constraint:
	 *     procName=Process
	 */
	protected void sequence_Atomic(ISerializationContext context, GetInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getGetInstance_ProcName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getGetInstance_ProcName()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getProcNameProcessParserRuleCall_8_1_0(), semanticObject.getProcName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GetPID
	 *     Or returns GetPID
	 *     Or.Or_1_0 returns GetPID
	 *     And returns GetPID
	 *     And.And_1_0 returns GetPID
	 *     Equality returns GetPID
	 *     Equality.Equality_1_0 returns GetPID
	 *     Comparison returns GetPID
	 *     Comparison.Comparison_1_0 returns GetPID
	 *     PlusOrMinus returns GetPID
	 *     PlusOrMinus.Plus_1_0_0_0 returns GetPID
	 *     PlusOrMinus.Minus_1_0_1_0 returns GetPID
	 *     MulOrDiv returns GetPID
	 *     MulOrDiv.MulOrDiv_1_0 returns GetPID
	 *     Implies returns GetPID
	 *     Implies.Implies_1_0 returns GetPID
	 *     Primary returns GetPID
	 *     Atomic returns GetPID
	 *
	 * Constraint:
	 *     procName=Process
	 */
	protected void sequence_Atomic(ISerializationContext context, GetPID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getGetPID_ProcName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getGetPID_ProcName()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getProcNameProcessParserRuleCall_9_1_0(), semanticObject.getProcName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InstanceID
	 *     Or returns InstanceID
	 *     Or.Or_1_0 returns InstanceID
	 *     And returns InstanceID
	 *     And.And_1_0 returns InstanceID
	 *     Equality returns InstanceID
	 *     Equality.Equality_1_0 returns InstanceID
	 *     Comparison returns InstanceID
	 *     Comparison.Comparison_1_0 returns InstanceID
	 *     PlusOrMinus returns InstanceID
	 *     PlusOrMinus.Plus_1_0_0_0 returns InstanceID
	 *     PlusOrMinus.Minus_1_0_1_0 returns InstanceID
	 *     MulOrDiv returns InstanceID
	 *     MulOrDiv.MulOrDiv_1_0 returns InstanceID
	 *     Implies returns InstanceID
	 *     Implies.Implies_1_0 returns InstanceID
	 *     Primary returns InstanceID
	 *     Atomic returns InstanceID
	 *
	 * Constraint:
	 *     instanceID='<InstanceID>'
	 */
	protected void sequence_Atomic(ISerializationContext context, InstanceID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInstanceID_InstanceID()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInstanceID_InstanceID()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getInstanceIDInstanceIDKeyword_10_1_0(), semanticObject.getInstanceID());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns IntConstant
	 *     Implies returns IntConstant
	 *     Implies.Implies_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=NumValue
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getIntConstant_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getIntConstant_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueNumValueParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ProcessID
	 *     Or returns ProcessID
	 *     Or.Or_1_0 returns ProcessID
	 *     And returns ProcessID
	 *     And.And_1_0 returns ProcessID
	 *     Equality returns ProcessID
	 *     Equality.Equality_1_0 returns ProcessID
	 *     Comparison returns ProcessID
	 *     Comparison.Comparison_1_0 returns ProcessID
	 *     PlusOrMinus returns ProcessID
	 *     PlusOrMinus.Plus_1_0_0_0 returns ProcessID
	 *     PlusOrMinus.Minus_1_0_1_0 returns ProcessID
	 *     MulOrDiv returns ProcessID
	 *     MulOrDiv.MulOrDiv_1_0 returns ProcessID
	 *     Implies returns ProcessID
	 *     Implies.Implies_1_0 returns ProcessID
	 *     Primary returns ProcessID
	 *     Atomic returns ProcessID
	 *
	 * Constraint:
	 *     pID='<PID>'
	 */
	protected void sequence_Atomic(ISerializationContext context, ProcessID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getProcessID_PID()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getProcessID_PID()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getPIDPIDKeyword_11_1_0(), semanticObject.getPID());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ProcessName
	 *     Or returns ProcessName
	 *     Or.Or_1_0 returns ProcessName
	 *     And returns ProcessName
	 *     And.And_1_0 returns ProcessName
	 *     Equality returns ProcessName
	 *     Equality.Equality_1_0 returns ProcessName
	 *     Comparison returns ProcessName
	 *     Comparison.Comparison_1_0 returns ProcessName
	 *     PlusOrMinus returns ProcessName
	 *     PlusOrMinus.Plus_1_0_0_0 returns ProcessName
	 *     PlusOrMinus.Minus_1_0_1_0 returns ProcessName
	 *     MulOrDiv returns ProcessName
	 *     MulOrDiv.MulOrDiv_1_0 returns ProcessName
	 *     Implies returns ProcessName
	 *     Implies.Implies_1_0 returns ProcessName
	 *     Primary returns ProcessName
	 *     Atomic returns ProcessName
	 *
	 * Constraint:
	 *     pName='<PName>'
	 */
	protected void sequence_Atomic(ISerializationContext context, ProcessName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getProcessName_PName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getProcessName_PName()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getPNamePNameKeyword_12_1_0(), semanticObject.getPName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StateID
	 *     Or returns StateID
	 *     Or.Or_1_0 returns StateID
	 *     And returns StateID
	 *     And.And_1_0 returns StateID
	 *     Equality returns StateID
	 *     Equality.Equality_1_0 returns StateID
	 *     Comparison returns StateID
	 *     Comparison.Comparison_1_0 returns StateID
	 *     PlusOrMinus returns StateID
	 *     PlusOrMinus.Plus_1_0_0_0 returns StateID
	 *     PlusOrMinus.Minus_1_0_1_0 returns StateID
	 *     MulOrDiv returns StateID
	 *     MulOrDiv.MulOrDiv_1_0 returns StateID
	 *     Implies returns StateID
	 *     Implies.Implies_1_0 returns StateID
	 *     Primary returns StateID
	 *     Atomic returns StateID
	 *
	 * Constraint:
	 *     stateID='<StateID>'
	 */
	protected void sequence_Atomic(ISerializationContext context, StateID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getStateID_StateID()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getStateID_StateID()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getStateIDStateIDKeyword_3_1_0(), semanticObject.getStateID());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Step
	 *     Or returns Step
	 *     Or.Or_1_0 returns Step
	 *     And returns Step
	 *     And.And_1_0 returns Step
	 *     Equality returns Step
	 *     Equality.Equality_1_0 returns Step
	 *     Comparison returns Step
	 *     Comparison.Comparison_1_0 returns Step
	 *     PlusOrMinus returns Step
	 *     PlusOrMinus.Plus_1_0_0_0 returns Step
	 *     PlusOrMinus.Minus_1_0_1_0 returns Step
	 *     MulOrDiv returns Step
	 *     MulOrDiv.MulOrDiv_1_0 returns Step
	 *     Implies returns Step
	 *     Implies.Implies_1_0 returns Step
	 *     Primary returns Step
	 *     Atomic returns Step
	 *
	 * Constraint:
	 *     step='getStep()'
	 */
	protected void sequence_Atomic(ISerializationContext context, Step semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getStep_Step()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getStep_Step()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getStepGetStepKeyword_6_1_0(), semanticObject.getStep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TotalStep
	 *     Or returns TotalStep
	 *     Or.Or_1_0 returns TotalStep
	 *     And returns TotalStep
	 *     And.And_1_0 returns TotalStep
	 *     Equality returns TotalStep
	 *     Equality.Equality_1_0 returns TotalStep
	 *     Comparison returns TotalStep
	 *     Comparison.Comparison_1_0 returns TotalStep
	 *     PlusOrMinus returns TotalStep
	 *     PlusOrMinus.Plus_1_0_0_0 returns TotalStep
	 *     PlusOrMinus.Minus_1_0_1_0 returns TotalStep
	 *     MulOrDiv returns TotalStep
	 *     MulOrDiv.MulOrDiv_1_0 returns TotalStep
	 *     Implies returns TotalStep
	 *     Implies.Implies_1_0 returns TotalStep
	 *     Primary returns TotalStep
	 *     Atomic returns TotalStep
	 *
	 * Constraint:
	 *     totalstep='getTotalStep()'
	 */
	protected void sequence_Atomic(ISerializationContext context, TotalStep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getTotalStep_Totalstep()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getTotalStep_Totalstep()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getTotalstepGetTotalStepKeyword_7_1_0(), semanticObject.getTotalstep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttDef returns AttDef
	 *
	 * Constraint:
	 *     (name=ID type=VariableType list=ListDef? default=Value)
	 */
	protected void sequence_AttDef(ISerializationContext context, AttDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (att+=AttDef* constraints=Constraints?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Behavior returns Behavior
	 *
	 * Constraint:
	 *     (eventtemplate+=EventTemplate eventtemplate+=EventTemplate*)
	 */
	protected void sequence_Behavior(ISerializationContext context, Behavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BlockStatement
	 *     BlockStatement returns BlockStatement
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_BlockStatement(ISerializationContext context, BlockStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoolValue returns BoolValue
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BoolValue(ISerializationContext context, BoolValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CTL_AT returns CTL_AT
	 *
	 * Constraint:
	 *     cond=Expression
	 */
	protected void sequence_CTL_AT(ISerializationContext context, CTL_AT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getCTL_AT_Cond()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getCTL_AT_Cond()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCTL_ATAccess().getCondExpressionParserRuleCall_1_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CallFunction
	 *     CallFunction returns CallFunction
	 *
	 * Constraint:
	 *     (funcName=FunctionName process=Process parameterlist=InterfaceParameterList?)
	 */
	protected void sequence_CallFunction(ISerializationContext context, CallFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChanDec returns ChanDec
	 *
	 * Constraint:
	 *     (cname=ID ivalue=NumValue type=TypeName)
	 */
	protected void sequence_ChanDec(ISerializationContext context, ChanDec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getChanDec_Cname()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getChanDec_Cname()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getChanDec_Ivalue()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getChanDec_Ivalue()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getChanDec_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getChanDec_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChanDecAccess().getCnameIDTerminalRuleCall_1_0(), semanticObject.getCname());
		feeder.accept(grammarAccess.getChanDecAccess().getIvalueNumValueParserRuleCall_4_0(), semanticObject.getIvalue());
		feeder.accept(grammarAccess.getChanDecAccess().getTypeTypeNameEnumRuleCall_8_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ChangeAction returns ChangeAction
	 *
	 * Constraint:
	 *     (sta+=ChangeValue | sta+=AssertStatement)*
	 */
	protected void sequence_ChangeAction(ISerializationContext context, ChangeAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ChangeListValue
	 *     ASSIGN returns ChangeListValue
	 *     Statement returns ChangeListValue
	 *     ChangeValue returns ChangeListValue
	 *     ChangeListValue returns ChangeListValue
	 *
	 * Constraint:
	 *     (lvar=ListElement exp=Expression)
	 */
	protected void sequence_ChangeListValue(ISerializationContext context, ChangeListValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getChangeListValue_Lvar()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getChangeListValue_Lvar()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getChangeListValue_Exp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getChangeListValue_Exp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeListValueAccess().getLvarListElementParserRuleCall_0_0(), semanticObject.getLvar());
		feeder.accept(grammarAccess.getChangeListValueAccess().getExpExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ChangeValueExpression
	 *     ASSIGN returns ChangeValueExpression
	 *     Statement returns ChangeValueExpression
	 *     ChangeValue returns ChangeValueExpression
	 *     ChangeValueExpression returns ChangeValueExpression
	 *
	 * Constraint:
	 *     (var=QualifiedNames exp=Expression)
	 */
	protected void sequence_ChangeValueExpression(ISerializationContext context, ChangeValueExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getAtomic_Var()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getAtomic_Var()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getChangeValueExpression_Exp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getChangeValueExpression_Exp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeValueExpressionAccess().getVarQualifiedNamesParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getChangeValueExpressionAccess().getExpExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ChangeValueUnOp
	 *     ASSIGN returns ChangeValueUnOp
	 *     Statement returns ChangeValueUnOp
	 *     ChangeValue returns ChangeValueUnOp
	 *     ChangeValueUnOp returns ChangeValueUnOp
	 *
	 * Constraint:
	 *     (var=QualifiedNames (op='++' | op='--'))
	 */
	protected void sequence_ChangeValueUnOp(ISerializationContext context, ChangeValueUnOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CheckPoint
	 *     CheckPoint returns CheckPoint
	 *
	 * Constraint:
	 *     pointid=PointID
	 */
	protected void sequence_CheckPoint(ISerializationContext context, CheckPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getCheckPoint_Pointid()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getCheckPoint_Pointid()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckPointAccess().getPointidPointIDParserRuleCall_1_0(), semanticObject.getPointid());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CollectionInit returns CollectionInit
	 *
	 * Constraint:
	 *     (colName=SchedulerSet (set=Set | empty='empty' | full='full'))
	 */
	protected void sequence_CollectionInit(ISerializationContext context, CollectionInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompVarDef returns CompVarDef
	 *
	 * Constraint:
	 *     vard+=CompVarDefination*
	 */
	protected void sequence_CompVarDef(ISerializationContext context, CompVarDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompVarDefination returns CompVarDefination
	 *
	 * Constraint:
	 *     (type=VariableType name+=CompVarName name+=CompVarName* pvalue=Value?)
	 */
	protected void sequence_CompVarDefination(ISerializationContext context, CompVarDefination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompVarName returns CompVarName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_CompVarName(ISerializationContext context, CompVarName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getCompVarName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getCompVarName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompVarNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComparationDef returns ComparationDef
	 *
	 * Constraint:
	 *     (cname=ComparationName process1=Process process2=Process statements+=Statement*)
	 */
	protected void sequence_ComparationDef(ISerializationContext context, ComparationDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComparationName returns ComparationName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ComparationName(ISerializationContext context, ComparationName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getComparationName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getComparationName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparationNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     PlusOrMinus returns Comparison
	 *     PlusOrMinus.Plus_1_0_0_0 returns Comparison
	 *     PlusOrMinus.Minus_1_0_1_0 returns Comparison
	 *     MulOrDiv returns Comparison
	 *     MulOrDiv.MulOrDiv_1_0 returns Comparison
	 *     Implies returns Comparison
	 *     Implies.Implies_1_0 returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=ID template=SetTemplate? (stm+=GenCodeStatement | stm+=GenLnCodeStatement)*)
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     expr=Or
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getCondition_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getCondition_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getExprOrParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConfigProcess returns ConfigProcess
	 *
	 * Constraint:
	 *     (sporadic=SporadicProcess | periodic=PeriodicProcess)
	 */
	protected void sequence_ConfigProcess(ISerializationContext context, ConfigProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Config returns Config
	 *
	 * Constraint:
	 *     (name=ID config=Configuration)
	 */
	protected void sequence_Config(ISerializationContext context, Config semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getConfig_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getConfig_Name()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getConfig_Config()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getConfig_Config()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConfigAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConfigAccess().getConfigConfigurationParserRuleCall_1_0(), semanticObject.getConfig());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Configs returns Configs
	 *
	 * Constraint:
	 *     config+=Config*
	 */
	protected void sequence_Configs(ISerializationContext context, Configs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (var+=VarInit* collection+=CollectionInit* (proc=ID (nul='null' | element=Element))?)
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstDec returns ConstDec
	 *
	 * Constraint:
	 *     (name=ID (bvalue=BoolValue | ivalue=NumValue))
	 */
	protected void sequence_ConstDec(ISerializationContext context, ConstDec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     condition=Condition
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getConstraint_Condition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getConstraint_Condition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getConditionConditionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraints returns Constraints
	 *
	 * Constraint:
	 *     constraint+=Constraint*
	 */
	protected void sequence_Constraints(ISerializationContext context, Constraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (processname=ID paralist=ParameterList?)
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataBlockDef returns DataBlockDef
	 *
	 * Constraint:
	 *     datadef+=DataSingleDef*
	 */
	protected void sequence_DataBlockDef(ISerializationContext context, DataBlockDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataDef returns DataDef
	 *
	 * Constraint:
	 *     (ifdef=IfDef? (datablockdef=DataBlockDef | datasingledef=DataSingleDef))
	 */
	protected void sequence_DataDef(ISerializationContext context, DataDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataSingleDef returns DataSingleDef
	 *
	 * Constraint:
	 *     (prop=SchedulerPropertyDef | col=SchedulerCollectionDef)
	 */
	protected void sequence_DataSingleDef(ISerializationContext context, DataSingleDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclareEvent returns DeclareEvent
	 *
	 * Constraint:
	 *     event=Event
	 */
	protected void sequence_DeclareEvent(ISerializationContext context, DeclareEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getDeclareEvent_Event()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getDeclareEvent_Event()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclareEventAccess().getEventEventParserRuleCall_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclareList returns DeclareList
	 *
	 * Constraint:
	 *     (dec+=OneDec dec+=OneDec*)
	 */
	protected void sequence_DeclareList(ISerializationContext context, DeclareList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeclareProcess
	 *     DeclareProcess returns DeclareProcess
	 *
	 * Constraint:
	 *     process=Process
	 */
	protected void sequence_DeclareProcess(ISerializationContext context, DeclareProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getDeclareProcess_Process()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getDeclareProcess_Process()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclareProcessAccess().getProcessProcessParserRuleCall_1_0(), semanticObject.getProcess());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefBehaviorProc returns DefBehaviorProc
	 *
	 * Constraint:
	 *     (processbehaviors=ProcessBehaviors | proctype=ProcType)
	 */
	protected void sequence_DefBehaviorProc(ISerializationContext context, DefBehaviorProc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefCore returns DefCore
	 *
	 * Constraint:
	 *     numcore=INT
	 */
	protected void sequence_DefCore(ISerializationContext context, DefCore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getDefCore_Numcore()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getDefCore_Numcore()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefCoreAccess().getNumcoreINTTerminalRuleCall_4_0(), semanticObject.getNumcore());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Define returns Define
	 *
	 * Constraint:
	 *     (reflist+=RefList* function+=Function*)
	 */
	protected void sequence_Define(ISerializationContext context, Define semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Directory returns Directory
	 *
	 * Constraint:
	 *     name=CHAR_SEQUENCE
	 */
	protected void sequence_Directory(ISerializationContext context, Directory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getDirectory_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getDirectory_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectoryAccess().getNameCHAR_SEQUENCETerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ELABEL returns ELABEL
	 *
	 * Constraint:
	 *     label=ID
	 */
	protected void sequence_ELABEL(ISerializationContext context, ELABEL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getELABEL_Label()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getELABEL_Label()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getELABELAccess().getLabelIDTerminalRuleCall_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ELSEs returns ELSEs
	 *
	 * Constraint:
	 *     sequence=Action
	 */
	protected void sequence_ELSEs(ISerializationContext context, ELSEs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getELSEs_Sequence()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getELSEs_Sequence()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getELSEsAccess().getSequenceActionParserRuleCall_2_0(), semanticObject.getSequence());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ENAME returns ENAME
	 *
	 * Constraint:
	 *     (elabel=ELABEL | scheventname=EventName)
	 */
	protected void sequence_ENAME(ISerializationContext context, ENAME semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     (process=Process (paraAssign+=Value paraAssign+=Value*)?)
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EmptyExpression
	 *     Or returns EmptyExpression
	 *     Or.Or_1_0 returns EmptyExpression
	 *     And returns EmptyExpression
	 *     And.And_1_0 returns EmptyExpression
	 *     Equality returns EmptyExpression
	 *     Equality.Equality_1_0 returns EmptyExpression
	 *     Comparison returns EmptyExpression
	 *     Comparison.Comparison_1_0 returns EmptyExpression
	 *     PlusOrMinus returns EmptyExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns EmptyExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns EmptyExpression
	 *     MulOrDiv returns EmptyExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns EmptyExpression
	 *     Implies returns EmptyExpression
	 *     Implies.Implies_1_0 returns EmptyExpression
	 *     Primary returns EmptyExpression
	 *     EmptyExpression returns EmptyExpression
	 *
	 * Constraint:
	 *     col=SchedulerSet
	 */
	protected void sequence_EmptyExpression(ISerializationContext context, EmptyExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getEmptyExpression_Col()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getEmptyExpression_Col()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyExpressionAccess().getColSchedulerSetParserRuleCall_0_0(), semanticObject.getCol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnumDec returns EnumDec
	 *
	 * Constraint:
	 *     (type=EnumType enumele+=ID enumele+=ID*)
	 */
	protected void sequence_EnumDec(ISerializationContext context, EnumDec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumType returns EnumType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumType(ISerializationContext context, EnumType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getEnumType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getEnumType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumTypeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.MulOrDiv_1_0 returns Equality
	 *     Implies returns Equality
	 *     Implies.Implies_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventDef returns EventDef
	 *
	 * Constraint:
	 *     (eventname=EventName processname=Process? (event=EventOpt | event=EventStm))
	 */
	protected void sequence_EventDef(ISerializationContext context, EventDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventFunction returns EventFunction
	 *
	 * Constraint:
	 *     (name=ID funcpara=ParaListItem?)
	 */
	protected void sequence_EventFunction(ISerializationContext context, EventFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventOpt returns EventOpt
	 *
	 * Constraint:
	 *     (opt+=Opt opt+=Opt*)
	 */
	protected void sequence_EventOpt(ISerializationContext context, EventOpt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventStm returns EventStm
	 *
	 * Constraint:
	 *     (statements+=Stm statements+=Stm*)
	 */
	protected void sequence_EventStm(ISerializationContext context, EventStm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventTemplate returns EventTemplate
	 *
	 * Constraint:
	 *     (prefix=Expression? event=ActionName postfix=Expression?)
	 */
	protected void sequence_EventTemplate(ISerializationContext context, EventTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (elabel=ELABEL guard=Expression? (sequence=SequenceAction | eventfunction=EventFunction))
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecuteProcess returns ExecuteProcess
	 *
	 * Constraint:
	 *     process=Process
	 */
	protected void sequence_ExecuteProcess(ISerializationContext context, ExecuteProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getExecuteProcess_Process()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getExecuteProcess_Process()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExecuteProcessAccess().getProcessProcessParserRuleCall_1_0(), semanticObject.getProcess());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExistExpression
	 *     Or returns ExistExpression
	 *     Or.Or_1_0 returns ExistExpression
	 *     And returns ExistExpression
	 *     And.And_1_0 returns ExistExpression
	 *     Equality returns ExistExpression
	 *     Equality.Equality_1_0 returns ExistExpression
	 *     Comparison returns ExistExpression
	 *     Comparison.Comparison_1_0 returns ExistExpression
	 *     PlusOrMinus returns ExistExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns ExistExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns ExistExpression
	 *     MulOrDiv returns ExistExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns ExistExpression
	 *     Implies returns ExistExpression
	 *     Implies.Implies_1_0 returns ExistExpression
	 *     Primary returns ExistExpression
	 *     ExistExpression returns ExistExpression
	 *
	 * Constraint:
	 *     pN=CHAR_SEQUENCE
	 */
	protected void sequence_ExistExpression(ISerializationContext context, ExistExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getExistExpression_PN()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getExistExpression_PN()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistExpressionAccess().getPNCHAR_SEQUENCETerminalRuleCall_2_0(), semanticObject.getPN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExistPID
	 *     Or returns ExistPID
	 *     Or.Or_1_0 returns ExistPID
	 *     And returns ExistPID
	 *     And.And_1_0 returns ExistPID
	 *     Equality returns ExistPID
	 *     Equality.Equality_1_0 returns ExistPID
	 *     Comparison returns ExistPID
	 *     Comparison.Comparison_1_0 returns ExistPID
	 *     PlusOrMinus returns ExistPID
	 *     PlusOrMinus.Plus_1_0_0_0 returns ExistPID
	 *     PlusOrMinus.Minus_1_0_1_0 returns ExistPID
	 *     MulOrDiv returns ExistPID
	 *     MulOrDiv.MulOrDiv_1_0 returns ExistPID
	 *     Implies returns ExistPID
	 *     Implies.Implies_1_0 returns ExistPID
	 *     Primary returns ExistPID
	 *     ExistPID returns ExistPID
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_ExistPID(ISerializationContext context, ExistPID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getExistPID_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getExistPID_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistPIDAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExistP
	 *     Or returns ExistP
	 *     Or.Or_1_0 returns ExistP
	 *     And returns ExistP
	 *     And.And_1_0 returns ExistP
	 *     Equality returns ExistP
	 *     Equality.Equality_1_0 returns ExistP
	 *     Comparison returns ExistP
	 *     Comparison.Comparison_1_0 returns ExistP
	 *     PlusOrMinus returns ExistP
	 *     PlusOrMinus.Plus_1_0_0_0 returns ExistP
	 *     PlusOrMinus.Minus_1_0_1_0 returns ExistP
	 *     MulOrDiv returns ExistP
	 *     MulOrDiv.MulOrDiv_1_0 returns ExistP
	 *     Implies returns ExistP
	 *     Implies.Implies_1_0 returns ExistP
	 *     Primary returns ExistP
	 *     ExistP returns ExistP
	 *
	 * Constraint:
	 *     id=INT
	 */
	protected void sequence_ExistP(ISerializationContext context, ExistP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getExistP_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getExistP_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistPAccess().getIdINTTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FileExtension returns FileExtension
	 *
	 * Constraint:
	 *     name=CHAR_SEQUENCE
	 */
	protected void sequence_FileExtension(ISerializationContext context, FileExtension semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getFileExtension_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getFileExtension_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileExtensionAccess().getNameCHAR_SEQUENCETerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FileName returns FileName
	 *
	 * Constraint:
	 *     name=CHAR_SEQUENCE
	 */
	protected void sequence_FileName(ISerializationContext context, FileName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getFileName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getFileName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileNameAccess().getNameCHAR_SEQUENCETerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Flow returns Flow
	 *
	 * Constraint:
	 *     (event+=ENAME event+=ENAME*)
	 */
	protected void sequence_Flow(ISerializationContext context, Flow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FullExpression
	 *     Or returns FullExpression
	 *     Or.Or_1_0 returns FullExpression
	 *     And returns FullExpression
	 *     And.And_1_0 returns FullExpression
	 *     Equality returns FullExpression
	 *     Equality.Equality_1_0 returns FullExpression
	 *     Comparison returns FullExpression
	 *     Comparison.Comparison_1_0 returns FullExpression
	 *     PlusOrMinus returns FullExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns FullExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns FullExpression
	 *     MulOrDiv returns FullExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns FullExpression
	 *     Implies returns FullExpression
	 *     Implies.Implies_1_0 returns FullExpression
	 *     Primary returns FullExpression
	 *     FullExpression returns FullExpression
	 *
	 * Constraint:
	 *     col=SchedulerSet
	 */
	protected void sequence_FullExpression(ISerializationContext context, FullExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getFullExpression_Col()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getFullExpression_Col()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFullExpressionAccess().getColSchedulerSetParserRuleCall_0_0(), semanticObject.getCol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncPara returns FuncPara
	 *
	 * Constraint:
	 *     (para+=ID para+=ID*)
	 */
	protected void sequence_FuncPara(ISerializationContext context, FuncPara semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionName returns FunctionName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FunctionName(ISerializationContext context, FunctionName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getFunctionName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getFunctionName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID funcpara=FuncPara? sequence=SequenceAction)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns GUARD
	 *     GUARD returns GUARD
	 *
	 * Constraint:
	 *     (expr=Expression sequence=Action)
	 */
	protected void sequence_GUARD(ISerializationContext context, GUARD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getGUARD_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getGUARD_Expr()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getGUARD_Sequence()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getGUARD_Sequence()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGUARDAccess().getExprExpressionParserRuleCall_0_0(), semanticObject.getExpr());
		feeder.accept(grammarAccess.getGUARDAccess().getSequenceActionParserRuleCall_2_0(), semanticObject.getSequence());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GenCodeStatement
	 *     GenCodeStatement returns GenCodeStatement
	 *
	 * Constraint:
	 *     (comp=ID? st=Expression)
	 */
	protected void sequence_GenCodeStatement(ISerializationContext context, GenCodeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenComponent returns GenComponent
	 *
	 * Constraint:
	 *     (component+=Component component+=Component*)
	 */
	protected void sequence_GenComponent(ISerializationContext context, GenComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenConfiguration returns GenConfiguration
	 *
	 * Constraint:
	 *     (
	 *         generateoption=GenerateOption? 
	 *         directory=Directory? 
	 *         filename=FileName? 
	 *         fileextension=FileExtension? 
	 *         (test='program' | test='case' | test='data') 
	 *         testpart=TestPart
	 *     )
	 */
	protected void sequence_GenConfiguration(ISerializationContext context, GenConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenDSL returns GenDSL
	 *
	 * Constraint:
	 *     (gen=Generate function=InterfaceDef? isr=ISR)
	 */
	protected void sequence_GenDSL(ISerializationContext context, GenDSL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GenLnCodeStatement
	 *     GenLnCodeStatement returns GenLnCodeStatement
	 *
	 * Constraint:
	 *     (comp=ID? st=Expression)
	 */
	protected void sequence_GenLnCodeStatement(ISerializationContext context, GenLnCodeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenPart returns GenPart
	 *
	 * Constraint:
	 *     (prefix=CHAR_SEQUENCE? (name=ID | name='processes' | name='steps' | name='error') posfix=CHAR_SEQUENCE?)
	 */
	protected void sequence_GenPart(ISerializationContext context, GenPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenerateOption returns GenerateOption
	 *
	 * Constraint:
	 *     (option+=GenOption option+=GenOption*)
	 */
	protected void sequence_GenerateOption(ISerializationContext context, GenerateOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Generate returns Generate
	 *
	 * Constraint:
	 *     (genconfiguration=GenConfiguration gencomponent=GenComponent? (stepgeneration=StepGeneration | processgeneration=ProcessGeneration)?)
	 */
	protected void sequence_Generate(ISerializationContext context, Generate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GetIDExpression
	 *     Or returns GetIDExpression
	 *     Or.Or_1_0 returns GetIDExpression
	 *     And returns GetIDExpression
	 *     And.And_1_0 returns GetIDExpression
	 *     Equality returns GetIDExpression
	 *     Equality.Equality_1_0 returns GetIDExpression
	 *     Comparison returns GetIDExpression
	 *     Comparison.Comparison_1_0 returns GetIDExpression
	 *     PlusOrMinus returns GetIDExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns GetIDExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns GetIDExpression
	 *     MulOrDiv returns GetIDExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns GetIDExpression
	 *     Implies returns GetIDExpression
	 *     Implies.Implies_1_0 returns GetIDExpression
	 *     Primary returns GetIDExpression
	 *     GetIDExpression returns GetIDExpression
	 *
	 * Constraint:
	 *     pN=CHAR_SEQUENCE
	 */
	protected void sequence_GetIDExpression(ISerializationContext context, GetIDExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getGetIDExpression_PN()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getGetIDExpression_PN()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetIDExpressionAccess().getPNCHAR_SEQUENCETerminalRuleCall_2_0(), semanticObject.getPN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GetName
	 *     Or returns GetName
	 *     Or.Or_1_0 returns GetName
	 *     And returns GetName
	 *     And.And_1_0 returns GetName
	 *     Equality returns GetName
	 *     Equality.Equality_1_0 returns GetName
	 *     Comparison returns GetName
	 *     Comparison.Comparison_1_0 returns GetName
	 *     PlusOrMinus returns GetName
	 *     PlusOrMinus.Plus_1_0_0_0 returns GetName
	 *     PlusOrMinus.Minus_1_0_1_0 returns GetName
	 *     MulOrDiv returns GetName
	 *     MulOrDiv.MulOrDiv_1_0 returns GetName
	 *     Implies returns GetName
	 *     Implies.Implies_1_0 returns GetName
	 *     Primary returns GetName
	 *     GetName returns GetName
	 *
	 * Constraint:
	 *     proc=Process
	 */
	protected void sequence_GetName(ISerializationContext context, GetName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getGetName_Proc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getGetName_Proc()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetNameAccess().getProcProcessParserRuleCall_0_0(), semanticObject.getProc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GetProcess
	 *     GetProcess returns GetProcess
	 *
	 * Constraint:
	 *     (colFrom=SchedulerSet change=ChangeAction? (time=Expression colTo=SchedulerSet)?)
	 */
	protected void sequence_GetProcess(ISerializationContext context, GetProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HandlerDef returns HandlerDef
	 *
	 * Constraint:
	 *     event+=EventDef*
	 */
	protected void sequence_HandlerDef(ISerializationContext context, HandlerDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns HasIDINT
	 *     Or returns HasIDINT
	 *     Or.Or_1_0 returns HasIDINT
	 *     And returns HasIDINT
	 *     And.And_1_0 returns HasIDINT
	 *     Equality returns HasIDINT
	 *     Equality.Equality_1_0 returns HasIDINT
	 *     Comparison returns HasIDINT
	 *     Comparison.Comparison_1_0 returns HasIDINT
	 *     PlusOrMinus returns HasIDINT
	 *     PlusOrMinus.Plus_1_0_0_0 returns HasIDINT
	 *     PlusOrMinus.Minus_1_0_1_0 returns HasIDINT
	 *     MulOrDiv returns HasIDINT
	 *     MulOrDiv.MulOrDiv_1_0 returns HasIDINT
	 *     Implies returns HasIDINT
	 *     Implies.Implies_1_0 returns HasIDINT
	 *     Primary returns HasIDINT
	 *     HasIDINT returns HasIDINT
	 *
	 * Constraint:
	 *     (proc=Process id=INT)
	 */
	protected void sequence_HasIDINT(ISerializationContext context, HasIDINT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getHasIDINT_Proc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getHasIDINT_Proc()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getHasIDINT_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getHasIDINT_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHasIDINTAccess().getProcProcessParserRuleCall_0_0(), semanticObject.getProc());
		feeder.accept(grammarAccess.getHasIDINTAccess().getIdINTTerminalRuleCall_4_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns HasID
	 *     Or returns HasID
	 *     Or.Or_1_0 returns HasID
	 *     And returns HasID
	 *     And.And_1_0 returns HasID
	 *     Equality returns HasID
	 *     Equality.Equality_1_0 returns HasID
	 *     Comparison returns HasID
	 *     Comparison.Comparison_1_0 returns HasID
	 *     PlusOrMinus returns HasID
	 *     PlusOrMinus.Plus_1_0_0_0 returns HasID
	 *     PlusOrMinus.Minus_1_0_1_0 returns HasID
	 *     MulOrDiv returns HasID
	 *     MulOrDiv.MulOrDiv_1_0 returns HasID
	 *     Implies returns HasID
	 *     Implies.Implies_1_0 returns HasID
	 *     Primary returns HasID
	 *     HasID returns HasID
	 *
	 * Constraint:
	 *     (proc=Process id=ID)
	 */
	protected void sequence_HasID(ISerializationContext context, HasID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getHasID_Proc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getHasID_Proc()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getHasID_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getHasID_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHasIDAccess().getProcProcessParserRuleCall_0_0(), semanticObject.getProc());
		feeder.accept(grammarAccess.getHasIDAccess().getIdIDTerminalRuleCall_4_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns HasNameExpression
	 *     Or returns HasNameExpression
	 *     Or.Or_1_0 returns HasNameExpression
	 *     And returns HasNameExpression
	 *     And.And_1_0 returns HasNameExpression
	 *     Equality returns HasNameExpression
	 *     Equality.Equality_1_0 returns HasNameExpression
	 *     Comparison returns HasNameExpression
	 *     Comparison.Comparison_1_0 returns HasNameExpression
	 *     PlusOrMinus returns HasNameExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns HasNameExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns HasNameExpression
	 *     MulOrDiv returns HasNameExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns HasNameExpression
	 *     Implies returns HasNameExpression
	 *     Implies.Implies_1_0 returns HasNameExpression
	 *     Primary returns HasNameExpression
	 *     HasNameExpression returns HasNameExpression
	 *
	 * Constraint:
	 *     (proc=Process pN=CHAR_SEQUENCE)
	 */
	protected void sequence_HasNameExpression(ISerializationContext context, HasNameExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getHasNameExpression_Proc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getHasNameExpression_Proc()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getHasNameExpression_PN()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getHasNameExpression_PN()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHasNameExpressionAccess().getProcProcessParserRuleCall_0_0(), semanticObject.getProc());
		feeder.accept(grammarAccess.getHasNameExpressionAccess().getPNCHAR_SEQUENCETerminalRuleCall_4_0(), semanticObject.getPN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns IFs
	 *     IFs returns IFs
	 *
	 * Constraint:
	 *     option=Options
	 */
	protected void sequence_IFs(ISerializationContext context, IFs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getIFs_Option()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getIFs_Option()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIFsAccess().getOptionOptionsParserRuleCall_2_0(), semanticObject.getOption());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ISR returns ISR
	 *
	 * Constraint:
	 *     (element=Element start=INT end=INT max=INT?)
	 */
	protected void sequence_ISR(ISerializationContext context, ISR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfDef returns IfDef
	 *
	 * Constraint:
	 *     cond=Expression
	 */
	protected void sequence_IfDef(ISerializationContext context, IfDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getIfDef_Cond()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getIfDef_Cond()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfDefAccess().getCondExpressionParserRuleCall_3_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression thenBlock=Statement elseBlock=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Implies
	 *     Or returns Implies
	 *     Or.Or_1_0 returns Implies
	 *     And returns Implies
	 *     And.And_1_0 returns Implies
	 *     Equality returns Implies
	 *     Equality.Equality_1_0 returns Implies
	 *     Comparison returns Implies
	 *     Comparison.Comparison_1_0 returns Implies
	 *     PlusOrMinus returns Implies
	 *     PlusOrMinus.Plus_1_0_0_0 returns Implies
	 *     PlusOrMinus.Minus_1_0_1_0 returns Implies
	 *     MulOrDiv returns Implies
	 *     MulOrDiv.MulOrDiv_1_0 returns Implies
	 *     Implies returns Implies
	 *     Implies.Implies_1_0 returns Implies
	 *     Primary returns Implies
	 *
	 * Constraint:
	 *     (left=Implies_Implies_1_0 op='=>' right=Primary)
	 */
	protected void sequence_Implies(ISerializationContext context, Implies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getImplies_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getImplies_Left()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getImplies_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getImplies_Op()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getImplies_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getImplies_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpliesAccess().getImpliesLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImpliesAccess().getOpEqualsSignGreaterThanSignKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getImpliesAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InExpression
	 *     Or returns InExpression
	 *     Or.Or_1_0 returns InExpression
	 *     And returns InExpression
	 *     And.And_1_0 returns InExpression
	 *     Equality returns InExpression
	 *     Equality.Equality_1_0 returns InExpression
	 *     Comparison returns InExpression
	 *     Comparison.Comparison_1_0 returns InExpression
	 *     PlusOrMinus returns InExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns InExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns InExpression
	 *     MulOrDiv returns InExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns InExpression
	 *     Implies returns InExpression
	 *     Implies.Implies_1_0 returns InExpression
	 *     Primary returns InExpression
	 *     InExpression returns InExpression
	 *
	 * Constraint:
	 *     (col=SchedulerSet pN=CHAR_SEQUENCE)
	 */
	protected void sequence_InExpression(ISerializationContext context, InExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInExpression_Col()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInExpression_Col()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInExpression_PN()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInExpression_PN()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInExpressionAccess().getColSchedulerSetParserRuleCall_0_0(), semanticObject.getCol());
		feeder.accept(grammarAccess.getInExpressionAccess().getPNCHAR_SEQUENCETerminalRuleCall_4_0(), semanticObject.getPN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InPExpression
	 *     Or returns InPExpression
	 *     Or.Or_1_0 returns InPExpression
	 *     And returns InPExpression
	 *     And.And_1_0 returns InPExpression
	 *     Equality returns InPExpression
	 *     Equality.Equality_1_0 returns InPExpression
	 *     Comparison returns InPExpression
	 *     Comparison.Comparison_1_0 returns InPExpression
	 *     PlusOrMinus returns InPExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns InPExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns InPExpression
	 *     MulOrDiv returns InPExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns InPExpression
	 *     Implies returns InPExpression
	 *     Implies.Implies_1_0 returns InPExpression
	 *     Primary returns InPExpression
	 *     InPExpression returns InPExpression
	 *
	 * Constraint:
	 *     (col=SchedulerSet id=INT)
	 */
	protected void sequence_InPExpression(ISerializationContext context, InPExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInPExpression_Col()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInPExpression_Col()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInPExpression_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInPExpression_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInPExpressionAccess().getColSchedulerSetParserRuleCall_0_0(), semanticObject.getCol());
		feeder.accept(grammarAccess.getInPExpressionAccess().getIdINTTerminalRuleCall_4_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InPIDExpression
	 *     Or returns InPIDExpression
	 *     Or.Or_1_0 returns InPIDExpression
	 *     And returns InPIDExpression
	 *     And.And_1_0 returns InPIDExpression
	 *     Equality returns InPIDExpression
	 *     Equality.Equality_1_0 returns InPIDExpression
	 *     Comparison returns InPIDExpression
	 *     Comparison.Comparison_1_0 returns InPIDExpression
	 *     PlusOrMinus returns InPIDExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns InPIDExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns InPIDExpression
	 *     MulOrDiv returns InPIDExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns InPIDExpression
	 *     Implies returns InPIDExpression
	 *     Implies.Implies_1_0 returns InPIDExpression
	 *     Primary returns InPIDExpression
	 *     InPIDExpression returns InPIDExpression
	 *
	 * Constraint:
	 *     (col=SchedulerSet id=ID)
	 */
	protected void sequence_InPIDExpression(ISerializationContext context, InPIDExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInPIDExpression_Col()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInPIDExpression_Col()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInPIDExpression_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInPIDExpression_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInPIDExpressionAccess().getColSchedulerSetParserRuleCall_0_0(), semanticObject.getCol());
		feeder.accept(grammarAccess.getInPIDExpressionAccess().getIdIDTerminalRuleCall_4_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceDef returns InterfaceDef
	 *
	 * Constraint:
	 *     interfacefunction+=InterfaceFunction*
	 */
	protected void sequence_InterfaceDef(ISerializationContext context, InterfaceDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceFunction returns InterfaceFunction
	 *
	 * Constraint:
	 *     (functionname=FunctionName parameterlist=InterfaceParameterList? statements+=Stm*)
	 */
	protected void sequence_InterfaceFunction(ISerializationContext context, InterfaceFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceParameterDeclare returns InterfaceParameterDeclare
	 *
	 * Constraint:
	 *     (type=VariableType paraname=ID)
	 */
	protected void sequence_InterfaceParameterDeclare(ISerializationContext context, InterfaceParameterDeclare semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInterfaceParameterDeclare_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInterfaceParameterDeclare_Type()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getInterfaceParameterDeclare_Paraname()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getInterfaceParameterDeclare_Paraname()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterfaceParameterDeclareAccess().getTypeVariableTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getInterfaceParameterDeclareAccess().getParanameIDTerminalRuleCall_1_0(), semanticObject.getParaname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceParameterList returns InterfaceParameterList
	 *
	 * Constraint:
	 *     (para+=InterfaceParameterDeclare para+=InterfaceParameterDeclare*)
	 */
	protected void sequence_InterfaceParameterList(ISerializationContext context, InterfaceParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Invariants returns Invariatnts
	 *
	 * Constraint:
	 *     invariant+=Constraint*
	 */
	protected void sequence_Invariants(ISerializationContext context, Invariatnts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns JavaCode
	 *     JavaCode returns JavaCode
	 *
	 * Constraint:
	 *     code=ML_CODE
	 */
	protected void sequence_JavaCode(ISerializationContext context, JavaCode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getJavaCode_Code()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getJavaCode_Code()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJavaCodeAccess().getCodeML_CODETerminalRuleCall_1_0(), semanticObject.getCode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LTE returns LTE
	 *
	 * Constraint:
	 *     num=INT
	 */
	protected void sequence_LTE(ISerializationContext context, LTE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getLTE_Num()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getLTE_Num()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLTEAccess().getNumINTTerminalRuleCall_1_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListDef returns ListDef
	 *
	 * Constraint:
	 *     (list+=List list+=List*)
	 */
	protected void sequence_ListDef(ISerializationContext context, ListDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListElement returns ListElement
	 *
	 * Constraint:
	 *     (name=ID (id=ID | num=INT))
	 */
	protected void sequence_ListElement(ISerializationContext context, ListElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     (range=Range | num=NumValue | id=ID | bool=BoolValue)
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LoopProcess
	 *     LoopProcess returns LoopProcess
	 *
	 * Constraint:
	 *     (pname=Process colFrom=SchedulerSet statement=Statement)
	 */
	protected void sequence_LoopProcess(ISerializationContext context, LoopProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getLoopProcess_Pname()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getLoopProcess_Pname()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getLoopProcess_ColFrom()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getLoopProcess_ColFrom()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getLoopProcess_Statement()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getLoopProcess_Statement()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopProcessAccess().getPnameProcessParserRuleCall_3_0(), semanticObject.getPname());
		feeder.accept(grammarAccess.getLoopProcessAccess().getColFromSchedulerSetParserRuleCall_5_0(), semanticObject.getColFrom());
		feeder.accept(grammarAccess.getLoopProcessAccess().getStatementStatementParserRuleCall_6_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (functionname=FunctionName (parameterlist=InterfaceParameterList assignparameters+=AssignParameters* constraints=Constraints?)?)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (gen=GenDSL | processconfig=ProcessConfiguration | proc=ProcessDSL | sch=SchedulerDSL | test=TestDSL)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MoveProcess
	 *     MoveProcess returns MoveProcess
	 *
	 * Constraint:
	 *     (process=Process colTo=SchedulerSet)
	 */
	protected void sequence_MoveProcess(ISerializationContext context, MoveProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getMoveProcess_Process()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getMoveProcess_Process()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getMoveProcess_ColTo()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getMoveProcess_ColTo()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveProcessAccess().getProcessProcessParserRuleCall_1_0(), semanticObject.getProcess());
		feeder.accept(grammarAccess.getMoveProcessAccess().getColToSchedulerSetParserRuleCall_3_0(), semanticObject.getColTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDiv
	 *     Or returns MulOrDiv
	 *     Or.Or_1_0 returns MulOrDiv
	 *     And returns MulOrDiv
	 *     And.And_1_0 returns MulOrDiv
	 *     Equality returns MulOrDiv
	 *     Equality.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparison_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0_0 returns MulOrDiv
	 *     PlusOrMinus.Minus_1_0_1_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0 returns MulOrDiv
	 *     Implies returns MulOrDiv
	 *     Implies.Implies_1_0 returns MulOrDiv
	 *     Primary returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0 (op='*' | op='/') right=Implies)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ND_Behavior returns ND_Behavior
	 *
	 * Constraint:
	 *     (cond=Expression? eventtemplate+=EventTemplate eventtemplate+=EventTemplate*)
	 */
	protected void sequence_ND_Behavior(ISerializationContext context, ND_Behavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NewElement returns NewElement
	 *
	 * Constraint:
	 *     (process=Process (paraAssign+=ParaValue paraAssign+=ParaValue*)?)
	 */
	protected void sequence_NewElement(ISerializationContext context, NewElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NewProcessStatement
	 *     NewProcessStatement returns NewProcessStatement
	 *
	 * Constraint:
	 *     (element=NewElement max=INT?)
	 */
	protected void sequence_NewProcessStatement(ISerializationContext context, NewProcessStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullExpression
	 *     Or returns NullExpression
	 *     Or.Or_1_0 returns NullExpression
	 *     And returns NullExpression
	 *     And.And_1_0 returns NullExpression
	 *     Equality returns NullExpression
	 *     Equality.Equality_1_0 returns NullExpression
	 *     Comparison returns NullExpression
	 *     Comparison.Comparison_1_0 returns NullExpression
	 *     PlusOrMinus returns NullExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns NullExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns NullExpression
	 *     MulOrDiv returns NullExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns NullExpression
	 *     Implies returns NullExpression
	 *     Implies.Implies_1_0 returns NullExpression
	 *     Primary returns NullExpression
	 *     NullExpression returns NullExpression
	 *
	 * Constraint:
	 *     procName=Process
	 */
	protected void sequence_NullExpression(ISerializationContext context, NullExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getNullExpression_ProcName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getNullExpression_ProcName()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullExpressionAccess().getProcNameProcessParserRuleCall_0_0(), semanticObject.getProcName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumValue returns NumValue
	 *
	 * Constraint:
	 *     (minus='-'? value=INT)
	 */
	protected void sequence_NumValue(ISerializationContext context, NumValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OneDec returns OneDec
	 *
	 * Constraint:
	 *     (const=ConstDec | var=VarDec | enumdec=EnumDec)
	 */
	protected void sequence_OneDec(ISerializationContext context, OneDec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Opt returns Opt
	 *
	 * Constraint:
	 *     eventstm=EventStm
	 */
	protected void sequence_Opt(ISerializationContext context, Opt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getOpt_Eventstm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getOpt_Eventstm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptAccess().getEventstmEventStmParserRuleCall_2_0(), semanticObject.getEventstm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Options returns Options
	 *
	 * Constraint:
	 *     (sequence+=SequenceAction sequence+=SequenceAction* elses=ELSEs?)
	 */
	protected void sequence_Options(ISerializationContext context, Options semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.MulOrDiv_1_0 returns Or
	 *     Implies returns Or
	 *     Implies.Implies_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getOr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getOr_Left()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getOr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getOr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OrderingDef returns OrderingDef
	 *
	 * Constraint:
	 *     (vars=CompVarDef? compare+=ComparationDef*)
	 */
	protected void sequence_OrderingDef(ISerializationContext context, OrderingDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParaListItem returns ParaListItem
	 *
	 * Constraint:
	 *     (item+=RefListItem item+=RefListItem*)
	 */
	protected void sequence_ParaListItem(ISerializationContext context, ParaListItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParaValue returns ParaValue
	 *
	 * Constraint:
	 *     (num=NumValue | bool=BoolValue | id=ID)
	 */
	protected void sequence_ParaValue(ISerializationContext context, ParaValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterAssign returns ParameterAssign
	 *
	 * Constraint:
	 *     (type=VariableType paraname+=ParameterName paraname+=ParameterName* val=Value?)
	 */
	protected void sequence_ParameterAssign(ISerializationContext context, ParameterAssign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (para+=ParameterAssign para+=ParameterAssign*)
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterName returns ParameterName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ParameterName(ISerializationContext context, ParameterName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getParameterName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getParameterName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PeriodicProcess returns PeriodicProcess
	 *
	 * Constraint:
	 *     (element=Element offset=NumValue period=NumValue max=INT?)
	 */
	protected void sequence_PeriodicProcess(ISerializationContext context, PeriodicProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Permutation returns Permutation
	 *
	 * Constraint:
	 *     step=INT
	 */
	protected void sequence_Permutation(ISerializationContext context, Permutation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getPermutation_Step()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getPermutation_Step()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPermutationAccess().getStepINTTerminalRuleCall_5_0(), semanticObject.getStep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.MulOrDiv_1_0 returns Minus
	 *     Implies returns Minus
	 *     Implies.Implies_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getMinus_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getMinus_Left()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getMinus_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getMinus_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.MulOrDiv_1_0 returns Plus
	 *     Implies returns Plus
	 *     Implies.Implies_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getPlus_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getPlus_Left()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getPlus_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getPlus_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PointID returns PointID
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PointID(ISerializationContext context, PointID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getPointID_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getPointID_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointIDAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.MulOrDiv_1_0 returns Not
	 *     Implies returns Not
	 *     Implies.Implies_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getNot_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getNot_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintLogStatement
	 *     PrintLogStatement returns PrintLogStatement
	 *
	 * Constraint:
	 *     st=Expression
	 */
	protected void sequence_PrintLogStatement(ISerializationContext context, PrintLogStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getPrintLogStatement_St()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getPrintLogStatement_St()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintLogStatementAccess().getStExpressionParserRuleCall_1_0(), semanticObject.getSt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintStatement
	 *     PrintStatement returns PrintStatement
	 *
	 * Constraint:
	 *     st=Expression
	 */
	protected void sequence_PrintStatement(ISerializationContext context, PrintStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getPrintStatement_St()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getPrintStatement_St()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintStatementAccess().getStExpressionParserRuleCall_1_0(), semanticObject.getSt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcType returns ProcType
	 *
	 * Constraint:
	 *     proctype+=ProcessType*
	 */
	protected void sequence_ProcType(ISerializationContext context, ProcType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessBehavior returns ProcessBehavior
	 *
	 * Constraint:
	 *     (constructor=Constructor | method=Method)
	 */
	protected void sequence_ProcessBehavior(ISerializationContext context, ProcessBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessBehaviors returns ProcessBehaviors
	 *
	 * Constraint:
	 *     processbehavior+=ProcessBehavior*
	 */
	protected void sequence_ProcessBehaviors(ISerializationContext context, ProcessBehaviors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessConfig returns ProcessConfig
	 *
	 * Constraint:
	 *     procinit+=ConfigProcess*
	 */
	protected void sequence_ProcessConfig(ISerializationContext context, ProcessConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessConfiguration returns ProcessConfiguration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parent=ID? 
	 *         attribute=Attribute? 
	 *         defbehaviorproc=DefBehaviorProc 
	 *         processconfig=ProcessConfig? 
	 *         processinit=ProcessInit
	 *     )
	 */
	protected void sequence_ProcessConfiguration(ISerializationContext context, ProcessConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessDSL returns ProcessDSL
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parent=ID? 
	 *         processdata=ProcessDataDef? 
	 *         constraints=Constraints? 
	 *         process+=ProcessDef* 
	 *         processconfig=ProcessConfig? 
	 *         processinit=ProcessInit?
	 *     )
	 */
	protected void sequence_ProcessDSL(ISerializationContext context, ProcessDSL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessDataDef returns ProcessDataDef
	 *
	 * Constraint:
	 *     properties+=ProcessPropertyDef*
	 */
	protected void sequence_ProcessDataDef(ISerializationContext context, ProcessDataDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessDef returns ProcessDef
	 *
	 * Constraint:
	 *     (proctype=Process paralist=ParameterList? propertyassignment+=PropertyAssignment*)
	 */
	protected void sequence_ProcessDef(ISerializationContext context, ProcessDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessGeneration returns ProcessGeneration
	 *
	 * Constraint:
	 *     process=Template
	 */
	protected void sequence_ProcessGeneration(ISerializationContext context, ProcessGeneration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getProcessGeneration_Process()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getProcessGeneration_Process()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessGenerationAccess().getProcessTemplateParserRuleCall_2_0(), semanticObject.getProcess());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessInit returns ProcessInit
	 *
	 * Constraint:
	 *     (order+=Set order+=Set*)
	 */
	protected void sequence_ProcessInit(ISerializationContext context, ProcessInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessPropertyDef returns ProcessPropertyDef
	 *
	 * Constraint:
	 *     ((var?='var' | val?='val')? type=VariableType name+=ProcessPropertyName name+=ProcessPropertyName* pvalue=Value?)
	 */
	protected void sequence_ProcessPropertyDef(ISerializationContext context, ProcessPropertyDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessPropertyName returns ProcessPropertyName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProcessPropertyName(ISerializationContext context, ProcessPropertyName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getProcessPropertyName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getProcessPropertyName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessPropertyNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessType returns ProcessType
	 *
	 * Constraint:
	 *     (name=ID constraints=Constraints? processbehavior+=ProcessBehavior*)
	 */
	protected void sequence_ProcessType(ISerializationContext context, ProcessType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Process returns Process
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Process(ISerializationContext context, scheduling.dsl.Process semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getProcess_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getProcess_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Proper returns Proper
	 *
	 * Constraint:
	 *     prop=ProcessPropertyName
	 */
	protected void sequence_Proper(ISerializationContext context, Proper semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getProper_Prop()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getProper_Prop()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProperAccess().getPropProcessPropertyNameParserRuleCall_1_0(), semanticObject.getProp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyAssignment returns PropertyAssignment
	 *
	 * Constraint:
	 *     (propers=ProcessPropertyName (pvalue=Value | pname=ParameterName))
	 */
	protected void sequence_PropertyAssignment(ISerializationContext context, PropertyAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualifiedNames returns QualifiedNames
	 *
	 * Constraint:
	 *     (name=ID prop=ProcessPropertyName?)
	 */
	protected void sequence_QualifiedNames(ISerializationContext context, QualifiedNames semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RTCTL returns RTCTL
	 *
	 * Constraint:
	 *     (
	 *         (op='(' exp=Expression) | 
	 *         (op='not' f=RTCTL) | 
	 *         (op='or' f1=RTCTL f2=RTCTL) | 
	 *         (op='implies' f1=RTCTL f2=RTCTL) | 
	 *         (op='AX' f=RTCTL) | 
	 *         (op='AF' lte=LTE? f=RTCTL) | 
	 *         (op='AG' lte=LTE? f=RTCTL) | 
	 *         (op='EX' f=RTCTL) | 
	 *         (op='EF' lte=LTE? f=RTCTL) | 
	 *         (op='EG' lte=LTE? f=RTCTL) | 
	 *         (op='AU' lte=LTE? f1=RTCTL f2=RTCTL) | 
	 *         (op='EU' lte=LTE? f1=RTCTL f2=RTCTL)
	 *     )
	 */
	protected void sequence_RTCTL(ISerializationContext context, RTCTL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (start=NumValue end=NumValue)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getRange_Start()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getRange_Start()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getRange_End()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getRange_End()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getStartNumValueParserRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getRangeAccess().getEndNumValueParserRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefListItem returns RefListItem
	 *
	 * Constraint:
	 *     (bvalue=BoolValue | ivalue=NumValue | id=ID)
	 */
	protected void sequence_RefListItem(ISerializationContext context, RefListItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefList returns RefList
	 *
	 * Constraint:
	 *     (name=ID item+=RefListItem item+=RefListItem*)
	 */
	protected void sequence_RefList(ISerializationContext context, RefList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RemoveProcess
	 *     RemoveProcess returns RemoveProcess
	 *
	 * Constraint:
	 *     process=Process
	 */
	protected void sequence_RemoveProcess(ISerializationContext context, RemoveProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getRemoveProcess_Process()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getRemoveProcess_Process()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveProcessAccess().getProcessProcessParserRuleCall_1_0(), semanticObject.getProcess());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReorderProcess
	 *     ReorderProcess returns ReorderProcess
	 *
	 * Constraint:
	 *     (process=Process colTo=SchedulerSet)
	 */
	protected void sequence_ReorderProcess(ISerializationContext context, ReorderProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getReorderProcess_Process()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getReorderProcess_Process()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getReorderProcess_ColTo()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getReorderProcess_ColTo()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReorderProcessAccess().getProcessProcessParserRuleCall_1_0(), semanticObject.getProcess());
		feeder.accept(grammarAccess.getReorderProcessAccess().getColToSchedulerSetParserRuleCall_3_0(), semanticObject.getColTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReturnStatement returns ReturnStatement
	 *     Statement returns ReturnStatement
	 *
	 * Constraint:
	 *     value=OrderType
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getReturnStatement_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getReturnStatement_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getValueOrderTypeEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (rulename=ID ename=ENAME premise=Condition? conclude=Condition)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rules returns Rules
	 *
	 * Constraint:
	 *     r+=Rule*
	 */
	protected void sequence_Rules(ISerializationContext context, Rules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns SKIP
	 *     SKIP returns SKIP
	 *
	 * Constraint:
	 *     {SKIP}
	 */
	protected void sequence_SKIP(ISerializationContext context, SKIP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scenarios returns Scenarios
	 *
	 * Constraint:
	 *     flow+=Flow*
	 */
	protected void sequence_Scenarios(ISerializationContext context, Scenarios semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerCollectionDef returns SchedulerCollectionDef
	 *
	 * Constraint:
	 *     (parent='refines'? name=SchedulerSet (comp+=ComparationName comp+=ComparationName*)? operationtype=OperationType?)
	 */
	protected void sequence_SchedulerCollectionDef(ISerializationContext context, SchedulerCollectionDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerDSL returns SchedulerDSL
	 *
	 * Constraint:
	 *     (defcore=DefCore? scheduler=SchedulerDef order=OrderingDef? verify=Verify?)
	 */
	protected void sequence_SchedulerDSL(ISerializationContext context, SchedulerDSL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerDataDef returns SchedulerDataDef
	 *
	 * Constraint:
	 *     datadef+=DataDef*
	 */
	protected void sequence_SchedulerDataDef(ISerializationContext context, SchedulerDataDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerDef returns SchedulerDef
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parameterlist=ParameterList? 
	 *         parent=ID? 
	 *         gen=Generate? 
	 *         svar=VarDef? 
	 *         schedulerdata=SchedulerDataDef? 
	 *         schedulerinit=SchedulerInit? 
	 *         handler=HandlerDef? 
	 *         interface=InterfaceDef?
	 *     )
	 */
	protected void sequence_SchedulerDef(ISerializationContext context, SchedulerDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerInit returns SchedulerInit
	 *
	 * Constraint:
	 *     initstm+=Statement*
	 */
	protected void sequence_SchedulerInit(ISerializationContext context, SchedulerInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerPropertyDef returns SchedulerPropertyDef
	 *
	 * Constraint:
	 *     (type=VariableType name+=SchedulerPropertyName name+=SchedulerPropertyName* (bvalue=BoolValue | ivalue=NumValue)?)
	 */
	protected void sequence_SchedulerPropertyDef(ISerializationContext context, SchedulerPropertyDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerPropertyName returns SchedulerPropertyName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SchedulerPropertyName(ISerializationContext context, SchedulerPropertyName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSchedulerPropertyName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSchedulerPropertyName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSchedulerPropertyNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SchedulerSet returns SchedulerSet
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SchedulerSet(ISerializationContext context, SchedulerSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSchedulerSet_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSchedulerSet_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSchedulerSetAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SequenceAction returns SequenceAction
	 *
	 * Constraint:
	 *     (action+=Action action+=Action*)
	 */
	protected void sequence_SequenceAction(ISerializationContext context, SequenceAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetExecTime
	 *     SetExecTime returns SetExecTime
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_SetExecTime(ISerializationContext context, SetExecTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSetExecTime_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSetExecTime_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetExecTimeAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetProcessInstance
	 *     SetProcessInstance returns SetProcessInstance
	 *
	 * Constraint:
	 *     (process=Process colTo=SchedulerSet)
	 */
	protected void sequence_SetProcessInstance(ISerializationContext context, SetProcessInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSetProcessInstance_Process()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSetProcessInstance_Process()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSetProcessInstance_ColTo()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSetProcessInstance_ColTo()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetProcessInstanceAccess().getProcessProcessParserRuleCall_1_0(), semanticObject.getProcess());
		feeder.accept(grammarAccess.getSetProcessInstanceAccess().getColToSchedulerSetParserRuleCall_3_0(), semanticObject.getColTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetProcess
	 *     SetProcess returns SetProcess
	 *
	 * Constraint:
	 *     (process=Process (id=INT | pid=ID))
	 */
	protected void sequence_SetProcess(ISerializationContext context, SetProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetReturnCol
	 *     SetReturnCol returns SetReturnCol
	 *
	 * Constraint:
	 *     col=SchedulerSet
	 */
	protected void sequence_SetReturnCol(ISerializationContext context, SetReturnCol semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSetReturnCol_Col()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSetReturnCol_Col()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetReturnColAccess().getColSchedulerSetParserRuleCall_2_0(), semanticObject.getCol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetReturnSet
	 *     SetReturnSet returns SetReturnSet
	 *
	 * Constraint:
	 *     (col+=SchedulerSet col+=SchedulerSet*)
	 */
	protected void sequence_SetReturnSet(ISerializationContext context, SetReturnSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetTemplate returns SetTemplate
	 *
	 * Constraint:
	 *     templ=Expression
	 */
	protected void sequence_SetTemplate(ISerializationContext context, SetTemplate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSetTemplate_Templ()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSetTemplate_Templ()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTemplateAccess().getTemplExpressionParserRuleCall_2_0(), semanticObject.getTempl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Set returns Set
	 *
	 * Constraint:
	 *     (set='{' element+=Element element+=Element*)
	 */
	protected void sequence_Set(ISerializationContext context, scheduling.dsl.Set semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Specification returns Specification
	 *
	 * Constraint:
	 *     (decl_lst=DeclareList? define=Define? event+=DeclareEvent*)
	 */
	protected void sequence_Specification(ISerializationContext context, Specification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SporadicProcess returns SporadicProcess
	 *
	 * Constraint:
	 *     (element=Element start=INT end=INT max=INT?)
	 */
	protected void sequence_SporadicProcess(ISerializationContext context, SporadicProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StepGeneration returns StepGeneration
	 *
	 * Constraint:
	 *     step=Template
	 */
	protected void sequence_StepGeneration(ISerializationContext context, StepGeneration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getStepGeneration_Step()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getStepGeneration_Step()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStepGenerationAccess().getStepTemplateParserRuleCall_2_0(), semanticObject.getStep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stm returns Stm
	 *
	 * Constraint:
	 *     (ifdef=IfDef? statement=Statement)
	 */
	protected void sequence_Stm(ISerializationContext context, Stm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SysVar returns SysVar
	 *
	 * Constraint:
	 *     vname=ID
	 */
	protected void sequence_SysVar(ISerializationContext context, SysVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getSysVar_Vname()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getSysVar_Vname()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSysVarAccess().getVnameIDTerminalRuleCall_2_0(), semanticObject.getVname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Template returns Template
	 *
	 * Constraint:
	 *     (template=SetTemplate? behavior=Behavior ND_behavior=ND_Behavior?)
	 */
	protected void sequence_Template(ISerializationContext context, Template semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDSL returns TestDSL
	 *
	 * Constraint:
	 *     (specification=Specification configs=Configs? (scenarios=Scenarios | permutation=Permutation) rule=Rules? verify=Verify?)
	 */
	protected void sequence_TestDSL(ISerializationContext context, TestDSL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestPart returns TestPart
	 *
	 * Constraint:
	 *     (part+=GenPart part+=GenPart*)
	 */
	protected void sequence_TestPart(ISerializationContext context, TestPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VDec returns VDec
	 *
	 * Constraint:
	 *     (name=ID (bvalue=BoolValue | ivalue=NumValue)?)
	 */
	protected void sequence_VDec(ISerializationContext context, VDec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (num=NumValue | bool=BoolValue | nondef='?' | list=ListDef)
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarBlockDef returns VarBlockDef
	 *
	 * Constraint:
	 *     vardef+=VarDefinition
	 */
	protected void sequence_VarBlockDef(ISerializationContext context, VarBlockDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDec returns VarDec
	 *
	 * Constraint:
	 *     ((type=TypeName | enumtype=[EnumType|ID]) name+=VDec name+=VDec*)
	 */
	protected void sequence_VarDec(ISerializationContext context, VarDec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (ifdef=IfDef? (varblockdef=VarBlockDef | varsingledef=VarSingleDef))
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDef returns VarDef
	 *
	 * Constraint:
	 *     vard+=VarDecl*
	 */
	protected void sequence_VarDef(ISerializationContext context, VarDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDefinition returns VarDefinition
	 *
	 * Constraint:
	 *     (type=VariableType name+=VarName name+=VarName* (bvalue=BoolValue | ivalue=NumValue)?)
	 */
	protected void sequence_VarDefinition(ISerializationContext context, VarDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarInit returns VarInit
	 *
	 * Constraint:
	 *     (varName=ID val=Value)
	 */
	protected void sequence_VarInit(ISerializationContext context, VarInit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getVarInit_VarName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getVarInit_VarName()));
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getVarInit_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getVarInit_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarInitAccess().getVarNameIDTerminalRuleCall_0_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getVarInitAccess().getValValueParserRuleCall_2_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarName returns VarName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VarName(ISerializationContext context, VarName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getVarName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getVarName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSingleDef returns VarSingleDef
	 *
	 * Constraint:
	 *     vardef=VarDefinition
	 */
	protected void sequence_VarSingleDef(ISerializationContext context, VarSingleDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.eINSTANCE.getVarSingleDef_Vardef()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.eINSTANCE.getVarSingleDef_Vardef()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarSingleDefAccess().getVardefVarDefinitionParserRuleCall_0(), semanticObject.getVardef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Verify returns Verify
	 *
	 * Constraint:
	 *     (at=CTL_AT? formula=RTCTL)
	 */
	protected void sequence_Verify(ISerializationContext context, Verify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
